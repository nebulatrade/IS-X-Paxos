// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: paxos.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_paxos_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_paxos_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_paxos_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_paxos_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace alisql {
class ClusterInfoEntry;
struct ClusterInfoEntryDefaultTypeInternal;
extern ClusterInfoEntryDefaultTypeInternal _ClusterInfoEntry_default_instance_;
class CompressedLogEntries;
struct CompressedLogEntriesDefaultTypeInternal;
extern CompressedLogEntriesDefaultTypeInternal _CompressedLogEntries_default_instance_;
class ConfigureChangeValue;
struct ConfigureChangeValueDefaultTypeInternal;
extern ConfigureChangeValueDefaultTypeInternal _ConfigureChangeValue_default_instance_;
class LogEntry;
struct LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class PaxosMsg;
struct PaxosMsgDefaultTypeInternal;
extern PaxosMsgDefaultTypeInternal _PaxosMsg_default_instance_;
class PolarFields;
struct PolarFieldsDefaultTypeInternal;
extern PolarFieldsDefaultTypeInternal _PolarFields_default_instance_;
class RDSFields;
struct RDSFieldsDefaultTypeInternal;
extern RDSFieldsDefaultTypeInternal _RDSFields_default_instance_;
class TestMsg1;
struct TestMsg1DefaultTypeInternal;
extern TestMsg1DefaultTypeInternal _TestMsg1_default_instance_;
class TestMsg2;
struct TestMsg2DefaultTypeInternal;
extern TestMsg2DefaultTypeInternal _TestMsg2_default_instance_;
}  // namespace alisql
PROTOBUF_NAMESPACE_OPEN
template<> ::alisql::ClusterInfoEntry* Arena::CreateMaybeMessage<::alisql::ClusterInfoEntry>(Arena*);
template<> ::alisql::CompressedLogEntries* Arena::CreateMaybeMessage<::alisql::CompressedLogEntries>(Arena*);
template<> ::alisql::ConfigureChangeValue* Arena::CreateMaybeMessage<::alisql::ConfigureChangeValue>(Arena*);
template<> ::alisql::LogEntry* Arena::CreateMaybeMessage<::alisql::LogEntry>(Arena*);
template<> ::alisql::PaxosMsg* Arena::CreateMaybeMessage<::alisql::PaxosMsg>(Arena*);
template<> ::alisql::PolarFields* Arena::CreateMaybeMessage<::alisql::PolarFields>(Arena*);
template<> ::alisql::RDSFields* Arena::CreateMaybeMessage<::alisql::RDSFields>(Arena*);
template<> ::alisql::TestMsg1* Arena::CreateMaybeMessage<::alisql::TestMsg1>(Arena*);
template<> ::alisql::TestMsg2* Arena::CreateMaybeMessage<::alisql::TestMsg2>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace alisql {

enum PaxosMsg_MsgErrorType : int {
  PaxosMsg_MsgErrorType_NONE = 0,
  PaxosMsg_MsgErrorType_APPEND = 1
};
bool PaxosMsg_MsgErrorType_IsValid(int value);
constexpr PaxosMsg_MsgErrorType PaxosMsg_MsgErrorType_MsgErrorType_MIN = PaxosMsg_MsgErrorType_NONE;
constexpr PaxosMsg_MsgErrorType PaxosMsg_MsgErrorType_MsgErrorType_MAX = PaxosMsg_MsgErrorType_APPEND;
constexpr int PaxosMsg_MsgErrorType_MsgErrorType_ARRAYSIZE = PaxosMsg_MsgErrorType_MsgErrorType_MAX + 1;

const std::string& PaxosMsg_MsgErrorType_Name(PaxosMsg_MsgErrorType value);
template<typename T>
inline const std::string& PaxosMsg_MsgErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaxosMsg_MsgErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaxosMsg_MsgErrorType_Name.");
  return PaxosMsg_MsgErrorType_Name(static_cast<PaxosMsg_MsgErrorType>(enum_t_value));
}
bool PaxosMsg_MsgErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaxosMsg_MsgErrorType* value);
// ===================================================================

class LogEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:alisql.LogEntry) */ {
 public:
  inline LogEntry() : LogEntry(nullptr) {}
  ~LogEntry() override;
  explicit constexpr LogEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogEntry(const LogEntry& from);
  LogEntry(LogEntry&& from) noexcept
    : LogEntry() {
    *this = ::std::move(from);
  }

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
               &_LogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LogEntry& a, LogEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(LogEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LogEntry& from);
  void MergeFrom(const LogEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alisql.LogEntry";
  }
  protected:
  explicit LogEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIkeyFieldNumber = 4,
    kValueFieldNumber = 5,
    kOpaqueFieldNumber = 9,
    kTermFieldNumber = 1,
    kIndexFieldNumber = 2,
    kOpTypeFieldNumber = 3,
    kInfoFieldNumber = 6,
    kChecksumFieldNumber = 7,
  };
  // optional bytes ikey = 4;
  bool has_ikey() const;
  private:
  bool _internal_has_ikey() const;
  public:
  void clear_ikey();
  const std::string& ikey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ikey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ikey();
  PROTOBUF_NODISCARD std::string* release_ikey();
  void set_allocated_ikey(std::string* ikey);
  private:
  const std::string& _internal_ikey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ikey(const std::string& value);
  std::string* _internal_mutable_ikey();
  public:

  // optional bytes value = 5;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional bytes opaque = 9;
  bool has_opaque() const;
  private:
  bool _internal_has_opaque() const;
  public:
  void clear_opaque();
  const std::string& opaque() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_opaque(ArgT0&& arg0, ArgT... args);
  std::string* mutable_opaque();
  PROTOBUF_NODISCARD std::string* release_opaque();
  void set_allocated_opaque(std::string* opaque);
  private:
  const std::string& _internal_opaque() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_opaque(const std::string& value);
  std::string* _internal_mutable_opaque();
  public:

  // required uint64 term = 1;
  bool has_term() const;
  private:
  bool _internal_has_term() const;
  public:
  void clear_term();
  uint64_t term() const;
  void set_term(uint64_t value);
  private:
  uint64_t _internal_term() const;
  void _internal_set_term(uint64_t value);
  public:

  // required uint64 index = 2;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint64_t index() const;
  void set_index(uint64_t value);
  private:
  uint64_t _internal_index() const;
  void _internal_set_index(uint64_t value);
  public:

  // required uint64 opType = 3;
  bool has_optype() const;
  private:
  bool _internal_has_optype() const;
  public:
  void clear_optype();
  uint64_t optype() const;
  void set_optype(uint64_t value);
  private:
  uint64_t _internal_optype() const;
  void _internal_set_optype(uint64_t value);
  public:

  // optional uint64 info = 6;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  uint64_t info() const;
  void set_info(uint64_t value);
  private:
  uint64_t _internal_info() const;
  void _internal_set_info(uint64_t value);
  public:

  // optional uint64 checksum = 7;
  bool has_checksum() const;
  private:
  bool _internal_has_checksum() const;
  public:
  void clear_checksum();
  uint64_t checksum() const;
  void set_checksum(uint64_t value);
  private:
  uint64_t _internal_checksum() const;
  void _internal_set_checksum(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:alisql.LogEntry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ikey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opaque_;
  uint64_t term_;
  uint64_t index_;
  uint64_t optype_;
  uint64_t info_;
  uint64_t checksum_;
  friend struct ::TableStruct_paxos_2eproto;
};
// -------------------------------------------------------------------

class RDSFields final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:alisql.RDSFields) */ {
 public:
  inline RDSFields() : RDSFields(nullptr) {}
  ~RDSFields() override;
  explicit constexpr RDSFields(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RDSFields(const RDSFields& from);
  RDSFields(RDSFields&& from) noexcept
    : RDSFields() {
    *this = ::std::move(from);
  }

  inline RDSFields& operator=(const RDSFields& from) {
    CopyFrom(from);
    return *this;
  }
  inline RDSFields& operator=(RDSFields&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RDSFields& default_instance() {
    return *internal_default_instance();
  }
  static inline const RDSFields* internal_default_instance() {
    return reinterpret_cast<const RDSFields*>(
               &_RDSFields_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RDSFields& a, RDSFields& b) {
    a.Swap(&b);
  }
  inline void Swap(RDSFields* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RDSFields* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RDSFields* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RDSFields>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RDSFields& from);
  void MergeFrom(const RDSFields& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RDSFields* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alisql.RDSFields";
  }
  protected:
  explicit RDSFields(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRdsServerIdFieldNumber = 1,
    kSourceFieldNumber = 2,
  };
  // optional uint32 rdsServerId = 1;
  bool has_rdsserverid() const;
  private:
  bool _internal_has_rdsserverid() const;
  public:
  void clear_rdsserverid();
  uint32_t rdsserverid() const;
  void set_rdsserverid(uint32_t value);
  private:
  uint32_t _internal_rdsserverid() const;
  void _internal_set_rdsserverid(uint32_t value);
  public:

  // optional uint32 source = 2;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  uint32_t source() const;
  void set_source(uint32_t value);
  private:
  uint32_t _internal_source() const;
  void _internal_set_source(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:alisql.RDSFields)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t rdsserverid_;
  uint32_t source_;
  friend struct ::TableStruct_paxos_2eproto;
};
// -------------------------------------------------------------------

class PolarFields final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:alisql.PolarFields) */ {
 public:
  inline PolarFields() : PolarFields(nullptr) {}
  ~PolarFields() override;
  explicit constexpr PolarFields(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolarFields(const PolarFields& from);
  PolarFields(PolarFields&& from) noexcept
    : PolarFields() {
    *this = ::std::move(from);
  }

  inline PolarFields& operator=(const PolarFields& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolarFields& operator=(PolarFields&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PolarFields& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolarFields* internal_default_instance() {
    return reinterpret_cast<const PolarFields*>(
               &_PolarFields_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PolarFields& a, PolarFields& b) {
    a.Swap(&b);
  }
  inline void Swap(PolarFields* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolarFields* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolarFields* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolarFields>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PolarFields& from);
  void MergeFrom(const PolarFields& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PolarFields* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alisql.PolarFields";
  }
  protected:
  explicit PolarFields(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtraValueFieldNumber = 3,
    kStartLsnFieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // optional bytes extra_value = 3;
  bool has_extra_value() const;
  private:
  bool _internal_has_extra_value() const;
  public:
  void clear_extra_value();
  const std::string& extra_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra_value();
  PROTOBUF_NODISCARD std::string* release_extra_value();
  void set_allocated_extra_value(std::string* extra_value);
  private:
  const std::string& _internal_extra_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra_value(const std::string& value);
  std::string* _internal_mutable_extra_value();
  public:

  // required uint64 start_lsn = 2;
  bool has_start_lsn() const;
  private:
  bool _internal_has_start_lsn() const;
  public:
  void clear_start_lsn();
  uint64_t start_lsn() const;
  void set_start_lsn(uint64_t value);
  private:
  uint64_t _internal_start_lsn() const;
  void _internal_set_start_lsn(uint64_t value);
  public:

  // required uint32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:alisql.PolarFields)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_value_;
  uint64_t start_lsn_;
  uint32_t version_;
  friend struct ::TableStruct_paxos_2eproto;
};
// -------------------------------------------------------------------

class CompressedLogEntries final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:alisql.CompressedLogEntries) */ {
 public:
  inline CompressedLogEntries() : CompressedLogEntries(nullptr) {}
  ~CompressedLogEntries() override;
  explicit constexpr CompressedLogEntries(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedLogEntries(const CompressedLogEntries& from);
  CompressedLogEntries(CompressedLogEntries&& from) noexcept
    : CompressedLogEntries() {
    *this = ::std::move(from);
  }

  inline CompressedLogEntries& operator=(const CompressedLogEntries& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedLogEntries& operator=(CompressedLogEntries&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CompressedLogEntries& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedLogEntries* internal_default_instance() {
    return reinterpret_cast<const CompressedLogEntries*>(
               &_CompressedLogEntries_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CompressedLogEntries& a, CompressedLogEntries& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedLogEntries* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedLogEntries* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedLogEntries* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedLogEntries>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CompressedLogEntries& from);
  void MergeFrom(const CompressedLogEntries& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CompressedLogEntries* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alisql.CompressedLogEntries";
  }
  protected:
  explicit CompressedLogEntries(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kTypeFieldNumber = 1,
    kRawSizeFieldNumber = 2,
    kChecksumFieldNumber = 4,
  };
  // required bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // required uint32 rawSize = 2;
  bool has_rawsize() const;
  private:
  bool _internal_has_rawsize() const;
  public:
  void clear_rawsize();
  uint32_t rawsize() const;
  void set_rawsize(uint32_t value);
  private:
  uint32_t _internal_rawsize() const;
  void _internal_set_rawsize(uint32_t value);
  public:

  // optional uint32 checksum = 4;
  bool has_checksum() const;
  private:
  bool _internal_has_checksum() const;
  public:
  void clear_checksum();
  uint32_t checksum() const;
  void set_checksum(uint32_t value);
  private:
  uint32_t _internal_checksum() const;
  void _internal_set_checksum(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:alisql.CompressedLogEntries)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  uint32_t type_;
  uint32_t rawsize_;
  uint32_t checksum_;
  friend struct ::TableStruct_paxos_2eproto;
};
// -------------------------------------------------------------------

class ConfigureChangeValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:alisql.ConfigureChangeValue) */ {
 public:
  inline ConfigureChangeValue() : ConfigureChangeValue(nullptr) {}
  ~ConfigureChangeValue() override;
  explicit constexpr ConfigureChangeValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigureChangeValue(const ConfigureChangeValue& from);
  ConfigureChangeValue(ConfigureChangeValue&& from) noexcept
    : ConfigureChangeValue() {
    *this = ::std::move(from);
  }

  inline ConfigureChangeValue& operator=(const ConfigureChangeValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigureChangeValue& operator=(ConfigureChangeValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConfigureChangeValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigureChangeValue* internal_default_instance() {
    return reinterpret_cast<const ConfigureChangeValue*>(
               &_ConfigureChangeValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConfigureChangeValue& a, ConfigureChangeValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigureChangeValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigureChangeValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigureChangeValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigureChangeValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConfigureChangeValue& from);
  void MergeFrom(const ConfigureChangeValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigureChangeValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alisql.ConfigureChangeValue";
  }
  protected:
  explicit ConfigureChangeValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrsFieldNumber = 3,
    kAllServersFieldNumber = 4,
    kAllLearnersFieldNumber = 5,
    kCcTypeFieldNumber = 1,
    kOpTypeFieldNumber = 2,
    kServerIdFieldNumber = 6,
    kForceSyncFieldNumber = 7,
    kElectionWeightFieldNumber = 8,
    kLearnerSourceFieldNumber = 9,
    kApplyModeFieldNumber = 10,
  };
  // repeated bytes addrs = 3;
  int addrs_size() const;
  private:
  int _internal_addrs_size() const;
  public:
  void clear_addrs();
  const std::string& addrs(int index) const;
  std::string* mutable_addrs(int index);
  void set_addrs(int index, const std::string& value);
  void set_addrs(int index, std::string&& value);
  void set_addrs(int index, const char* value);
  void set_addrs(int index, const void* value, size_t size);
  std::string* add_addrs();
  void add_addrs(const std::string& value);
  void add_addrs(std::string&& value);
  void add_addrs(const char* value);
  void add_addrs(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addrs();
  private:
  const std::string& _internal_addrs(int index) const;
  std::string* _internal_add_addrs();
  public:

  // repeated bytes allServers = 4;
  int allservers_size() const;
  private:
  int _internal_allservers_size() const;
  public:
  void clear_allservers();
  const std::string& allservers(int index) const;
  std::string* mutable_allservers(int index);
  void set_allservers(int index, const std::string& value);
  void set_allservers(int index, std::string&& value);
  void set_allservers(int index, const char* value);
  void set_allservers(int index, const void* value, size_t size);
  std::string* add_allservers();
  void add_allservers(const std::string& value);
  void add_allservers(std::string&& value);
  void add_allservers(const char* value);
  void add_allservers(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allservers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allservers();
  private:
  const std::string& _internal_allservers(int index) const;
  std::string* _internal_add_allservers();
  public:

  // repeated bytes allLearners = 5;
  int alllearners_size() const;
  private:
  int _internal_alllearners_size() const;
  public:
  void clear_alllearners();
  const std::string& alllearners(int index) const;
  std::string* mutable_alllearners(int index);
  void set_alllearners(int index, const std::string& value);
  void set_alllearners(int index, std::string&& value);
  void set_alllearners(int index, const char* value);
  void set_alllearners(int index, const void* value, size_t size);
  std::string* add_alllearners();
  void add_alllearners(const std::string& value);
  void add_alllearners(std::string&& value);
  void add_alllearners(const char* value);
  void add_alllearners(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& alllearners() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_alllearners();
  private:
  const std::string& _internal_alllearners(int index) const;
  std::string* _internal_add_alllearners();
  public:

  // optional int32 ccType = 1;
  bool has_cctype() const;
  private:
  bool _internal_has_cctype() const;
  public:
  void clear_cctype();
  int32_t cctype() const;
  void set_cctype(int32_t value);
  private:
  int32_t _internal_cctype() const;
  void _internal_set_cctype(int32_t value);
  public:

  // optional int32 opType = 2;
  bool has_optype() const;
  private:
  bool _internal_has_optype() const;
  public:
  void clear_optype();
  int32_t optype() const;
  void set_optype(int32_t value);
  private:
  int32_t _internal_optype() const;
  void _internal_set_optype(int32_t value);
  public:

  // optional uint64 serverId = 6;
  bool has_serverid() const;
  private:
  bool _internal_has_serverid() const;
  public:
  void clear_serverid();
  uint64_t serverid() const;
  void set_serverid(uint64_t value);
  private:
  uint64_t _internal_serverid() const;
  void _internal_set_serverid(uint64_t value);
  public:

  // optional uint32 forceSync = 7;
  bool has_forcesync() const;
  private:
  bool _internal_has_forcesync() const;
  public:
  void clear_forcesync();
  uint32_t forcesync() const;
  void set_forcesync(uint32_t value);
  private:
  uint32_t _internal_forcesync() const;
  void _internal_set_forcesync(uint32_t value);
  public:

  // optional uint32 electionWeight = 8;
  bool has_electionweight() const;
  private:
  bool _internal_has_electionweight() const;
  public:
  void clear_electionweight();
  uint32_t electionweight() const;
  void set_electionweight(uint32_t value);
  private:
  uint32_t _internal_electionweight() const;
  void _internal_set_electionweight(uint32_t value);
  public:

  // optional uint64 learnerSource = 9;
  bool has_learnersource() const;
  private:
  bool _internal_has_learnersource() const;
  public:
  void clear_learnersource();
  uint64_t learnersource() const;
  void set_learnersource(uint64_t value);
  private:
  uint64_t _internal_learnersource() const;
  void _internal_set_learnersource(uint64_t value);
  public:

  // optional bool applyMode = 10;
  bool has_applymode() const;
  private:
  bool _internal_has_applymode() const;
  public:
  void clear_applymode();
  bool applymode() const;
  void set_applymode(bool value);
  private:
  bool _internal_applymode() const;
  void _internal_set_applymode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:alisql.ConfigureChangeValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addrs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allservers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> alllearners_;
  int32_t cctype_;
  int32_t optype_;
  uint64_t serverid_;
  uint32_t forcesync_;
  uint32_t electionweight_;
  uint64_t learnersource_;
  bool applymode_;
  friend struct ::TableStruct_paxos_2eproto;
};
// -------------------------------------------------------------------

class ClusterInfoEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:alisql.ClusterInfoEntry) */ {
 public:
  inline ClusterInfoEntry() : ClusterInfoEntry(nullptr) {}
  ~ClusterInfoEntry() override;
  explicit constexpr ClusterInfoEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClusterInfoEntry(const ClusterInfoEntry& from);
  ClusterInfoEntry(ClusterInfoEntry&& from) noexcept
    : ClusterInfoEntry() {
    *this = ::std::move(from);
  }

  inline ClusterInfoEntry& operator=(const ClusterInfoEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClusterInfoEntry& operator=(ClusterInfoEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClusterInfoEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClusterInfoEntry* internal_default_instance() {
    return reinterpret_cast<const ClusterInfoEntry*>(
               &_ClusterInfoEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ClusterInfoEntry& a, ClusterInfoEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ClusterInfoEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClusterInfoEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClusterInfoEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClusterInfoEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClusterInfoEntry& from);
  void MergeFrom(const ClusterInfoEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClusterInfoEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alisql.ClusterInfoEntry";
  }
  protected:
  explicit ClusterInfoEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerIdFieldNumber = 1,
    kMatchIndexFieldNumber = 2,
    kNextIndexFieldNumber = 3,
    kHasVotedFieldNumber = 5,
    kRoleFieldNumber = 4,
    kForceSyncFieldNumber = 6,
    kLearnerSourceFieldNumber = 8,
    kElectionWeightFieldNumber = 7,
    kPipeliningFieldNumber = 10,
    kAppliedIndexFieldNumber = 9,
  };
  // required uint64 serverId = 1;
  bool has_serverid() const;
  private:
  bool _internal_has_serverid() const;
  public:
  void clear_serverid();
  uint64_t serverid() const;
  void set_serverid(uint64_t value);
  private:
  uint64_t _internal_serverid() const;
  void _internal_set_serverid(uint64_t value);
  public:

  // optional uint64 matchIndex = 2;
  bool has_matchindex() const;
  private:
  bool _internal_has_matchindex() const;
  public:
  void clear_matchindex();
  uint64_t matchindex() const;
  void set_matchindex(uint64_t value);
  private:
  uint64_t _internal_matchindex() const;
  void _internal_set_matchindex(uint64_t value);
  public:

  // optional uint64 nextIndex = 3;
  bool has_nextindex() const;
  private:
  bool _internal_has_nextindex() const;
  public:
  void clear_nextindex();
  uint64_t nextindex() const;
  void set_nextindex(uint64_t value);
  private:
  uint64_t _internal_nextindex() const;
  void _internal_set_nextindex(uint64_t value);
  public:

  // optional uint64 hasVoted = 5;
  bool has_hasvoted() const;
  private:
  bool _internal_has_hasvoted() const;
  public:
  void clear_hasvoted();
  uint64_t hasvoted() const;
  void set_hasvoted(uint64_t value);
  private:
  uint64_t _internal_hasvoted() const;
  void _internal_set_hasvoted(uint64_t value);
  public:

  // optional uint32 role = 4;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  uint32_t role() const;
  void set_role(uint32_t value);
  private:
  uint32_t _internal_role() const;
  void _internal_set_role(uint32_t value);
  public:

  // optional uint32 forceSync = 6;
  bool has_forcesync() const;
  private:
  bool _internal_has_forcesync() const;
  public:
  void clear_forcesync();
  uint32_t forcesync() const;
  void set_forcesync(uint32_t value);
  private:
  uint32_t _internal_forcesync() const;
  void _internal_set_forcesync(uint32_t value);
  public:

  // optional uint64 learnerSource = 8;
  bool has_learnersource() const;
  private:
  bool _internal_has_learnersource() const;
  public:
  void clear_learnersource();
  uint64_t learnersource() const;
  void set_learnersource(uint64_t value);
  private:
  uint64_t _internal_learnersource() const;
  void _internal_set_learnersource(uint64_t value);
  public:

  // optional uint32 electionWeight = 7;
  bool has_electionweight() const;
  private:
  bool _internal_has_electionweight() const;
  public:
  void clear_electionweight();
  uint32_t electionweight() const;
  void set_electionweight(uint32_t value);
  private:
  uint32_t _internal_electionweight() const;
  void _internal_set_electionweight(uint32_t value);
  public:

  // optional uint32 pipelining = 10;
  bool has_pipelining() const;
  private:
  bool _internal_has_pipelining() const;
  public:
  void clear_pipelining();
  uint32_t pipelining() const;
  void set_pipelining(uint32_t value);
  private:
  uint32_t _internal_pipelining() const;
  void _internal_set_pipelining(uint32_t value);
  public:

  // optional uint64 appliedIndex = 9;
  bool has_appliedindex() const;
  private:
  bool _internal_has_appliedindex() const;
  public:
  void clear_appliedindex();
  uint64_t appliedindex() const;
  void set_appliedindex(uint64_t value);
  private:
  uint64_t _internal_appliedindex() const;
  void _internal_set_appliedindex(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:alisql.ClusterInfoEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t serverid_;
  uint64_t matchindex_;
  uint64_t nextindex_;
  uint64_t hasvoted_;
  uint32_t role_;
  uint32_t forcesync_;
  uint64_t learnersource_;
  uint32_t electionweight_;
  uint32_t pipelining_;
  uint64_t appliedindex_;
  friend struct ::TableStruct_paxos_2eproto;
};
// -------------------------------------------------------------------

class PaxosMsg final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:alisql.PaxosMsg) */ {
 public:
  inline PaxosMsg() : PaxosMsg(nullptr) {}
  ~PaxosMsg() override;
  explicit constexpr PaxosMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaxosMsg(const PaxosMsg& from);
  PaxosMsg(PaxosMsg&& from) noexcept
    : PaxosMsg() {
    *this = ::std::move(from);
  }

  inline PaxosMsg& operator=(const PaxosMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaxosMsg& operator=(PaxosMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PaxosMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaxosMsg* internal_default_instance() {
    return reinterpret_cast<const PaxosMsg*>(
               &_PaxosMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PaxosMsg& a, PaxosMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(PaxosMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaxosMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaxosMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaxosMsg>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PaxosMsg& from);
  void MergeFrom(const PaxosMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PaxosMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alisql.PaxosMsg";
  }
  protected:
  explicit PaxosMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PaxosMsg_MsgErrorType MsgErrorType;
  static constexpr MsgErrorType NONE =
    PaxosMsg_MsgErrorType_NONE;
  static constexpr MsgErrorType APPEND =
    PaxosMsg_MsgErrorType_APPEND;
  static inline bool MsgErrorType_IsValid(int value) {
    return PaxosMsg_MsgErrorType_IsValid(value);
  }
  static constexpr MsgErrorType MsgErrorType_MIN =
    PaxosMsg_MsgErrorType_MsgErrorType_MIN;
  static constexpr MsgErrorType MsgErrorType_MAX =
    PaxosMsg_MsgErrorType_MsgErrorType_MAX;
  static constexpr int MsgErrorType_ARRAYSIZE =
    PaxosMsg_MsgErrorType_MsgErrorType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgErrorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgErrorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgErrorType_Name.");
    return PaxosMsg_MsgErrorType_Name(enum_t_value);
  }
  static inline bool MsgErrorType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MsgErrorType* value) {
    return PaxosMsg_MsgErrorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 10,
    kCiEntriesFieldNumber = 25,
    kAddrFieldNumber = 18,
    kExtraFieldNumber = 28,
    kCompressedEntriesFieldNumber = 27,
    kConfigIdFieldNumber = 1,
    kClusterIdFieldNumber = 2,
    kServerIdFieldNumber = 3,
    kTermFieldNumber = 5,
    kMsgIdFieldNumber = 6,
    kLeaderIdFieldNumber = 7,
    kPrevLogIndexFieldNumber = 8,
    kPrevLogTermFieldNumber = 9,
    kCommitIndexFieldNumber = 11,
    kMsgTypeFieldNumber = 4,
    kNocacheFieldNumber = 12,
    kIsSuccessFieldNumber = 13,
    kVoteGrantedFieldNumber = 19,
    kIgnoreCheckFieldNumber = 20,
    kCandidateIdFieldNumber = 14,
    kLastLogIndexFieldNumber = 15,
    kLastLogTermFieldNumber = 16,
    kForceFieldNumber = 17,
    kLcTypeFieldNumber = 21,
    kMinMatchIndexFieldNumber = 22,
    kAppliedIndexFieldNumber = 23,
    kNewClusterIdFieldNumber = 24,
    kRoleFieldNumber = 26,
    kMsgErrorFieldNumber = 30,
    kMyServerIdFieldNumber = 31,
  };
  // repeated .alisql.LogEntry entries = 10;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::alisql::LogEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alisql::LogEntry >*
      mutable_entries();
  private:
  const ::alisql::LogEntry& _internal_entries(int index) const;
  ::alisql::LogEntry* _internal_add_entries();
  public:
  const ::alisql::LogEntry& entries(int index) const;
  ::alisql::LogEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alisql::LogEntry >&
      entries() const;

  // repeated .alisql.ClusterInfoEntry ciEntries = 25;
  int cientries_size() const;
  private:
  int _internal_cientries_size() const;
  public:
  void clear_cientries();
  ::alisql::ClusterInfoEntry* mutable_cientries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alisql::ClusterInfoEntry >*
      mutable_cientries();
  private:
  const ::alisql::ClusterInfoEntry& _internal_cientries(int index) const;
  ::alisql::ClusterInfoEntry* _internal_add_cientries();
  public:
  const ::alisql::ClusterInfoEntry& cientries(int index) const;
  ::alisql::ClusterInfoEntry* add_cientries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alisql::ClusterInfoEntry >&
      cientries() const;

  // optional bytes addr = 18;
  bool has_addr() const;
  private:
  bool _internal_has_addr() const;
  public:
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // optional bytes extra = 28;
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const std::string& extra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra();
  PROTOBUF_NODISCARD std::string* release_extra();
  void set_allocated_extra(std::string* extra);
  private:
  const std::string& _internal_extra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra(const std::string& value);
  std::string* _internal_mutable_extra();
  public:

  // optional .alisql.CompressedLogEntries compressedEntries = 27;
  bool has_compressedentries() const;
  private:
  bool _internal_has_compressedentries() const;
  public:
  void clear_compressedentries();
  const ::alisql::CompressedLogEntries& compressedentries() const;
  PROTOBUF_NODISCARD ::alisql::CompressedLogEntries* release_compressedentries();
  ::alisql::CompressedLogEntries* mutable_compressedentries();
  void set_allocated_compressedentries(::alisql::CompressedLogEntries* compressedentries);
  private:
  const ::alisql::CompressedLogEntries& _internal_compressedentries() const;
  ::alisql::CompressedLogEntries* _internal_mutable_compressedentries();
  public:
  void unsafe_arena_set_allocated_compressedentries(
      ::alisql::CompressedLogEntries* compressedentries);
  ::alisql::CompressedLogEntries* unsafe_arena_release_compressedentries();

  // optional uint64 configId = 1;
  bool has_configid() const;
  private:
  bool _internal_has_configid() const;
  public:
  void clear_configid();
  uint64_t configid() const;
  void set_configid(uint64_t value);
  private:
  uint64_t _internal_configid() const;
  void _internal_set_configid(uint64_t value);
  public:

  // required uint64 clusterId = 2;
  bool has_clusterid() const;
  private:
  bool _internal_has_clusterid() const;
  public:
  void clear_clusterid();
  uint64_t clusterid() const;
  void set_clusterid(uint64_t value);
  private:
  uint64_t _internal_clusterid() const;
  void _internal_set_clusterid(uint64_t value);
  public:

  // required uint64 serverId = 3;
  bool has_serverid() const;
  private:
  bool _internal_has_serverid() const;
  public:
  void clear_serverid();
  uint64_t serverid() const;
  void set_serverid(uint64_t value);
  private:
  uint64_t _internal_serverid() const;
  void _internal_set_serverid(uint64_t value);
  public:

  // required uint64 term = 5;
  bool has_term() const;
  private:
  bool _internal_has_term() const;
  public:
  void clear_term();
  uint64_t term() const;
  void set_term(uint64_t value);
  private:
  uint64_t _internal_term() const;
  void _internal_set_term(uint64_t value);
  public:

  // required uint64 msgId = 6;
  bool has_msgid() const;
  private:
  bool _internal_has_msgid() const;
  public:
  void clear_msgid();
  uint64_t msgid() const;
  void set_msgid(uint64_t value);
  private:
  uint64_t _internal_msgid() const;
  void _internal_set_msgid(uint64_t value);
  public:

  // optional uint64 leaderId = 7;
  bool has_leaderid() const;
  private:
  bool _internal_has_leaderid() const;
  public:
  void clear_leaderid();
  uint64_t leaderid() const;
  void set_leaderid(uint64_t value);
  private:
  uint64_t _internal_leaderid() const;
  void _internal_set_leaderid(uint64_t value);
  public:

  // optional uint64 prevLogIndex = 8;
  bool has_prevlogindex() const;
  private:
  bool _internal_has_prevlogindex() const;
  public:
  void clear_prevlogindex();
  uint64_t prevlogindex() const;
  void set_prevlogindex(uint64_t value);
  private:
  uint64_t _internal_prevlogindex() const;
  void _internal_set_prevlogindex(uint64_t value);
  public:

  // optional uint64 prevLogTerm = 9;
  bool has_prevlogterm() const;
  private:
  bool _internal_has_prevlogterm() const;
  public:
  void clear_prevlogterm();
  uint64_t prevlogterm() const;
  void set_prevlogterm(uint64_t value);
  private:
  uint64_t _internal_prevlogterm() const;
  void _internal_set_prevlogterm(uint64_t value);
  public:

  // optional uint64 commitIndex = 11;
  bool has_commitindex() const;
  private:
  bool _internal_has_commitindex() const;
  public:
  void clear_commitindex();
  uint64_t commitindex() const;
  void set_commitindex(uint64_t value);
  private:
  uint64_t _internal_commitindex() const;
  void _internal_set_commitindex(uint64_t value);
  public:

  // required int32 msgType = 4;
  bool has_msgtype() const;
  private:
  bool _internal_has_msgtype() const;
  public:
  void clear_msgtype();
  int32_t msgtype() const;
  void set_msgtype(int32_t value);
  private:
  int32_t _internal_msgtype() const;
  void _internal_set_msgtype(int32_t value);
  public:

  // optional bool nocache = 12;
  bool has_nocache() const;
  private:
  bool _internal_has_nocache() const;
  public:
  void clear_nocache();
  bool nocache() const;
  void set_nocache(bool value);
  private:
  bool _internal_nocache() const;
  void _internal_set_nocache(bool value);
  public:

  // optional bool isSuccess = 13;
  bool has_issuccess() const;
  private:
  bool _internal_has_issuccess() const;
  public:
  void clear_issuccess();
  bool issuccess() const;
  void set_issuccess(bool value);
  private:
  bool _internal_issuccess() const;
  void _internal_set_issuccess(bool value);
  public:

  // optional bool voteGranted = 19;
  bool has_votegranted() const;
  private:
  bool _internal_has_votegranted() const;
  public:
  void clear_votegranted();
  bool votegranted() const;
  void set_votegranted(bool value);
  private:
  bool _internal_votegranted() const;
  void _internal_set_votegranted(bool value);
  public:

  // optional bool ignoreCheck = 20;
  bool has_ignorecheck() const;
  private:
  bool _internal_has_ignorecheck() const;
  public:
  void clear_ignorecheck();
  bool ignorecheck() const;
  void set_ignorecheck(bool value);
  private:
  bool _internal_ignorecheck() const;
  void _internal_set_ignorecheck(bool value);
  public:

  // optional uint64 candidateId = 14;
  bool has_candidateid() const;
  private:
  bool _internal_has_candidateid() const;
  public:
  void clear_candidateid();
  uint64_t candidateid() const;
  void set_candidateid(uint64_t value);
  private:
  uint64_t _internal_candidateid() const;
  void _internal_set_candidateid(uint64_t value);
  public:

  // optional uint64 lastLogIndex = 15;
  bool has_lastlogindex() const;
  private:
  bool _internal_has_lastlogindex() const;
  public:
  void clear_lastlogindex();
  uint64_t lastlogindex() const;
  void set_lastlogindex(uint64_t value);
  private:
  uint64_t _internal_lastlogindex() const;
  void _internal_set_lastlogindex(uint64_t value);
  public:

  // optional uint64 lastLogTerm = 16;
  bool has_lastlogterm() const;
  private:
  bool _internal_has_lastlogterm() const;
  public:
  void clear_lastlogterm();
  uint64_t lastlogterm() const;
  void set_lastlogterm(uint64_t value);
  private:
  uint64_t _internal_lastlogterm() const;
  void _internal_set_lastlogterm(uint64_t value);
  public:

  // optional uint64 force = 17;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  uint64_t force() const;
  void set_force(uint64_t value);
  private:
  uint64_t _internal_force() const;
  void _internal_set_force(uint64_t value);
  public:

  // optional uint64 lcType = 21;
  bool has_lctype() const;
  private:
  bool _internal_has_lctype() const;
  public:
  void clear_lctype();
  uint64_t lctype() const;
  void set_lctype(uint64_t value);
  private:
  uint64_t _internal_lctype() const;
  void _internal_set_lctype(uint64_t value);
  public:

  // optional uint64 minMatchIndex = 22;
  bool has_minmatchindex() const;
  private:
  bool _internal_has_minmatchindex() const;
  public:
  void clear_minmatchindex();
  uint64_t minmatchindex() const;
  void set_minmatchindex(uint64_t value);
  private:
  uint64_t _internal_minmatchindex() const;
  void _internal_set_minmatchindex(uint64_t value);
  public:

  // optional uint64 appliedIndex = 23;
  bool has_appliedindex() const;
  private:
  bool _internal_has_appliedindex() const;
  public:
  void clear_appliedindex();
  uint64_t appliedindex() const;
  void set_appliedindex(uint64_t value);
  private:
  uint64_t _internal_appliedindex() const;
  void _internal_set_appliedindex(uint64_t value);
  public:

  // optional uint64 newClusterId = 24;
  bool has_newclusterid() const;
  private:
  bool _internal_has_newclusterid() const;
  public:
  void clear_newclusterid();
  uint64_t newclusterid() const;
  void set_newclusterid(uint64_t value);
  private:
  uint64_t _internal_newclusterid() const;
  void _internal_set_newclusterid(uint64_t value);
  public:

  // optional uint32 role = 26;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  uint32_t role() const;
  void set_role(uint32_t value);
  private:
  uint32_t _internal_role() const;
  void _internal_set_role(uint32_t value);
  public:

  // optional .alisql.PaxosMsg.MsgErrorType msgError = 30;
  bool has_msgerror() const;
  private:
  bool _internal_has_msgerror() const;
  public:
  void clear_msgerror();
  ::alisql::PaxosMsg_MsgErrorType msgerror() const;
  void set_msgerror(::alisql::PaxosMsg_MsgErrorType value);
  private:
  ::alisql::PaxosMsg_MsgErrorType _internal_msgerror() const;
  void _internal_set_msgerror(::alisql::PaxosMsg_MsgErrorType value);
  public:

  // optional uint64 myServerId = 31;
  bool has_myserverid() const;
  private:
  bool _internal_has_myserverid() const;
  public:
  void clear_myserverid();
  uint64_t myserverid() const;
  void set_myserverid(uint64_t value);
  private:
  uint64_t _internal_myserverid() const;
  void _internal_set_myserverid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:alisql.PaxosMsg)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alisql::LogEntry > entries_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alisql::ClusterInfoEntry > cientries_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_;
  ::alisql::CompressedLogEntries* compressedentries_;
  uint64_t configid_;
  uint64_t clusterid_;
  uint64_t serverid_;
  uint64_t term_;
  uint64_t msgid_;
  uint64_t leaderid_;
  uint64_t prevlogindex_;
  uint64_t prevlogterm_;
  uint64_t commitindex_;
  int32_t msgtype_;
  bool nocache_;
  bool issuccess_;
  bool votegranted_;
  bool ignorecheck_;
  uint64_t candidateid_;
  uint64_t lastlogindex_;
  uint64_t lastlogterm_;
  uint64_t force_;
  uint64_t lctype_;
  uint64_t minmatchindex_;
  uint64_t appliedindex_;
  uint64_t newclusterid_;
  uint32_t role_;
  int msgerror_;
  uint64_t myserverid_;
  friend struct ::TableStruct_paxos_2eproto;
};
// -------------------------------------------------------------------

class TestMsg1 final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:alisql.TestMsg1) */ {
 public:
  inline TestMsg1() : TestMsg1(nullptr) {}
  ~TestMsg1() override;
  explicit constexpr TestMsg1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMsg1(const TestMsg1& from);
  TestMsg1(TestMsg1&& from) noexcept
    : TestMsg1() {
    *this = ::std::move(from);
  }

  inline TestMsg1& operator=(const TestMsg1& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMsg1& operator=(TestMsg1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TestMsg1& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMsg1* internal_default_instance() {
    return reinterpret_cast<const TestMsg1*>(
               &_TestMsg1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TestMsg1& a, TestMsg1& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMsg1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMsg1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMsg1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMsg1>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TestMsg1& from);
  void MergeFrom(const TestMsg1& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TestMsg1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alisql.TestMsg1";
  }
  protected:
  explicit TestMsg1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kC1FieldNumber = 2,
  };
  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // optional uint64 c1 = 2;
  bool has_c1() const;
  private:
  bool _internal_has_c1() const;
  public:
  void clear_c1();
  uint64_t c1() const;
  void set_c1(uint64_t value);
  private:
  uint64_t _internal_c1() const;
  void _internal_set_c1(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:alisql.TestMsg1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t id_;
  uint64_t c1_;
  friend struct ::TableStruct_paxos_2eproto;
};
// -------------------------------------------------------------------

class TestMsg2 final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:alisql.TestMsg2) */ {
 public:
  inline TestMsg2() : TestMsg2(nullptr) {}
  ~TestMsg2() override;
  explicit constexpr TestMsg2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMsg2(const TestMsg2& from);
  TestMsg2(TestMsg2&& from) noexcept
    : TestMsg2() {
    *this = ::std::move(from);
  }

  inline TestMsg2& operator=(const TestMsg2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMsg2& operator=(TestMsg2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TestMsg2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMsg2* internal_default_instance() {
    return reinterpret_cast<const TestMsg2*>(
               &_TestMsg2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TestMsg2& a, TestMsg2& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMsg2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMsg2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMsg2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMsg2>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TestMsg2& from);
  void MergeFrom(const TestMsg2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TestMsg2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alisql.TestMsg2";
  }
  protected:
  explicit TestMsg2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kC2FieldNumber = 3,
    kIdFieldNumber = 1,
    kC1FieldNumber = 2,
  };
  // repeated uint64 c2 = 3;
  int c2_size() const;
  private:
  int _internal_c2_size() const;
  public:
  void clear_c2();
  private:
  uint64_t _internal_c2(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_c2() const;
  void _internal_add_c2(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_c2();
  public:
  uint64_t c2(int index) const;
  void set_c2(int index, uint64_t value);
  void add_c2(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      c2() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_c2();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // optional uint64 c1 = 2;
  bool has_c1() const;
  private:
  bool _internal_has_c1() const;
  public:
  void clear_c1();
  uint64_t c1() const;
  void set_c1(uint64_t value);
  private:
  uint64_t _internal_c1() const;
  void _internal_set_c1(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:alisql.TestMsg2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > c2_;
  uint64_t id_;
  uint64_t c1_;
  friend struct ::TableStruct_paxos_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LogEntry

// required uint64 term = 1;
inline bool LogEntry::_internal_has_term() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LogEntry::has_term() const {
  return _internal_has_term();
}
inline void LogEntry::clear_term() {
  term_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t LogEntry::_internal_term() const {
  return term_;
}
inline uint64_t LogEntry::term() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.term)
  return _internal_term();
}
inline void LogEntry::_internal_set_term(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  term_ = value;
}
inline void LogEntry::set_term(uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:alisql.LogEntry.term)
}

// required uint64 index = 2;
inline bool LogEntry::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LogEntry::has_index() const {
  return _internal_has_index();
}
inline void LogEntry::clear_index() {
  index_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t LogEntry::_internal_index() const {
  return index_;
}
inline uint64_t LogEntry::index() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.index)
  return _internal_index();
}
inline void LogEntry::_internal_set_index(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  index_ = value;
}
inline void LogEntry::set_index(uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:alisql.LogEntry.index)
}

// required uint64 opType = 3;
inline bool LogEntry::_internal_has_optype() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LogEntry::has_optype() const {
  return _internal_has_optype();
}
inline void LogEntry::clear_optype() {
  optype_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t LogEntry::_internal_optype() const {
  return optype_;
}
inline uint64_t LogEntry::optype() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.opType)
  return _internal_optype();
}
inline void LogEntry::_internal_set_optype(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  optype_ = value;
}
inline void LogEntry::set_optype(uint64_t value) {
  _internal_set_optype(value);
  // @@protoc_insertion_point(field_set:alisql.LogEntry.opType)
}

// optional bytes ikey = 4;
inline bool LogEntry::_internal_has_ikey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogEntry::has_ikey() const {
  return _internal_has_ikey();
}
inline void LogEntry::clear_ikey() {
  ikey_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LogEntry::ikey() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.ikey)
  return _internal_ikey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_ikey(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ikey_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alisql.LogEntry.ikey)
}
inline std::string* LogEntry::mutable_ikey() {
  std::string* _s = _internal_mutable_ikey();
  // @@protoc_insertion_point(field_mutable:alisql.LogEntry.ikey)
  return _s;
}
inline const std::string& LogEntry::_internal_ikey() const {
  return ikey_.Get();
}
inline void LogEntry::_internal_set_ikey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ikey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_ikey() {
  _has_bits_[0] |= 0x00000001u;
  return ikey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LogEntry::release_ikey() {
  // @@protoc_insertion_point(field_release:alisql.LogEntry.ikey)
  if (!_internal_has_ikey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ikey_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ikey_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ikey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogEntry::set_allocated_ikey(std::string* ikey) {
  if (ikey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ikey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ikey,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ikey_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ikey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alisql.LogEntry.ikey)
}

// optional bytes value = 5;
inline bool LogEntry::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LogEntry::has_value() const {
  return _internal_has_value();
}
inline void LogEntry::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LogEntry::value() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alisql.LogEntry.value)
}
inline std::string* LogEntry::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:alisql.LogEntry.value)
  return _s;
}
inline const std::string& LogEntry::_internal_value() const {
  return value_.Get();
}
inline void LogEntry::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LogEntry::release_value() {
  // @@protoc_insertion_point(field_release:alisql.LogEntry.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogEntry::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alisql.LogEntry.value)
}

// optional uint64 info = 6;
inline bool LogEntry::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LogEntry::has_info() const {
  return _internal_has_info();
}
inline void LogEntry::clear_info() {
  info_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t LogEntry::_internal_info() const {
  return info_;
}
inline uint64_t LogEntry::info() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.info)
  return _internal_info();
}
inline void LogEntry::_internal_set_info(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  info_ = value;
}
inline void LogEntry::set_info(uint64_t value) {
  _internal_set_info(value);
  // @@protoc_insertion_point(field_set:alisql.LogEntry.info)
}

// optional uint64 checksum = 7;
inline bool LogEntry::_internal_has_checksum() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LogEntry::has_checksum() const {
  return _internal_has_checksum();
}
inline void LogEntry::clear_checksum() {
  checksum_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000080u;
}
inline uint64_t LogEntry::_internal_checksum() const {
  return checksum_;
}
inline uint64_t LogEntry::checksum() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.checksum)
  return _internal_checksum();
}
inline void LogEntry::_internal_set_checksum(uint64_t value) {
  _has_bits_[0] |= 0x00000080u;
  checksum_ = value;
}
inline void LogEntry::set_checksum(uint64_t value) {
  _internal_set_checksum(value);
  // @@protoc_insertion_point(field_set:alisql.LogEntry.checksum)
}

// optional bytes opaque = 9;
inline bool LogEntry::_internal_has_opaque() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LogEntry::has_opaque() const {
  return _internal_has_opaque();
}
inline void LogEntry::clear_opaque() {
  opaque_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LogEntry::opaque() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.opaque)
  return _internal_opaque();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_opaque(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 opaque_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alisql.LogEntry.opaque)
}
inline std::string* LogEntry::mutable_opaque() {
  std::string* _s = _internal_mutable_opaque();
  // @@protoc_insertion_point(field_mutable:alisql.LogEntry.opaque)
  return _s;
}
inline const std::string& LogEntry::_internal_opaque() const {
  return opaque_.Get();
}
inline void LogEntry::_internal_set_opaque(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  opaque_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_opaque() {
  _has_bits_[0] |= 0x00000004u;
  return opaque_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LogEntry::release_opaque() {
  // @@protoc_insertion_point(field_release:alisql.LogEntry.opaque)
  if (!_internal_has_opaque()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = opaque_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (opaque_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    opaque_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogEntry::set_allocated_opaque(std::string* opaque) {
  if (opaque != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  opaque_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), opaque,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (opaque_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    opaque_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alisql.LogEntry.opaque)
}

// -------------------------------------------------------------------

// RDSFields

// optional uint32 rdsServerId = 1;
inline bool RDSFields::_internal_has_rdsserverid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RDSFields::has_rdsserverid() const {
  return _internal_has_rdsserverid();
}
inline void RDSFields::clear_rdsserverid() {
  rdsserverid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t RDSFields::_internal_rdsserverid() const {
  return rdsserverid_;
}
inline uint32_t RDSFields::rdsserverid() const {
  // @@protoc_insertion_point(field_get:alisql.RDSFields.rdsServerId)
  return _internal_rdsserverid();
}
inline void RDSFields::_internal_set_rdsserverid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  rdsserverid_ = value;
}
inline void RDSFields::set_rdsserverid(uint32_t value) {
  _internal_set_rdsserverid(value);
  // @@protoc_insertion_point(field_set:alisql.RDSFields.rdsServerId)
}

// optional uint32 source = 2;
inline bool RDSFields::_internal_has_source() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RDSFields::has_source() const {
  return _internal_has_source();
}
inline void RDSFields::clear_source() {
  source_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RDSFields::_internal_source() const {
  return source_;
}
inline uint32_t RDSFields::source() const {
  // @@protoc_insertion_point(field_get:alisql.RDSFields.source)
  return _internal_source();
}
inline void RDSFields::_internal_set_source(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  source_ = value;
}
inline void RDSFields::set_source(uint32_t value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:alisql.RDSFields.source)
}

// -------------------------------------------------------------------

// PolarFields

// required uint32 version = 1;
inline bool PolarFields::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PolarFields::has_version() const {
  return _internal_has_version();
}
inline void PolarFields::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PolarFields::_internal_version() const {
  return version_;
}
inline uint32_t PolarFields::version() const {
  // @@protoc_insertion_point(field_get:alisql.PolarFields.version)
  return _internal_version();
}
inline void PolarFields::_internal_set_version(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  version_ = value;
}
inline void PolarFields::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:alisql.PolarFields.version)
}

// required uint64 start_lsn = 2;
inline bool PolarFields::_internal_has_start_lsn() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PolarFields::has_start_lsn() const {
  return _internal_has_start_lsn();
}
inline void PolarFields::clear_start_lsn() {
  start_lsn_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PolarFields::_internal_start_lsn() const {
  return start_lsn_;
}
inline uint64_t PolarFields::start_lsn() const {
  // @@protoc_insertion_point(field_get:alisql.PolarFields.start_lsn)
  return _internal_start_lsn();
}
inline void PolarFields::_internal_set_start_lsn(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  start_lsn_ = value;
}
inline void PolarFields::set_start_lsn(uint64_t value) {
  _internal_set_start_lsn(value);
  // @@protoc_insertion_point(field_set:alisql.PolarFields.start_lsn)
}

// optional bytes extra_value = 3;
inline bool PolarFields::_internal_has_extra_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PolarFields::has_extra_value() const {
  return _internal_has_extra_value();
}
inline void PolarFields::clear_extra_value() {
  extra_value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolarFields::extra_value() const {
  // @@protoc_insertion_point(field_get:alisql.PolarFields.extra_value)
  return _internal_extra_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolarFields::set_extra_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 extra_value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alisql.PolarFields.extra_value)
}
inline std::string* PolarFields::mutable_extra_value() {
  std::string* _s = _internal_mutable_extra_value();
  // @@protoc_insertion_point(field_mutable:alisql.PolarFields.extra_value)
  return _s;
}
inline const std::string& PolarFields::_internal_extra_value() const {
  return extra_value_.Get();
}
inline void PolarFields::_internal_set_extra_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PolarFields::_internal_mutable_extra_value() {
  _has_bits_[0] |= 0x00000001u;
  return extra_value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PolarFields::release_extra_value() {
  // @@protoc_insertion_point(field_release:alisql.PolarFields.extra_value)
  if (!_internal_has_extra_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = extra_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    extra_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolarFields::set_allocated_extra_value(std::string* extra_value) {
  if (extra_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  extra_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extra_value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    extra_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alisql.PolarFields.extra_value)
}

// -------------------------------------------------------------------

// CompressedLogEntries

// required uint32 type = 1;
inline bool CompressedLogEntries::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CompressedLogEntries::has_type() const {
  return _internal_has_type();
}
inline void CompressedLogEntries::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CompressedLogEntries::_internal_type() const {
  return type_;
}
inline uint32_t CompressedLogEntries::type() const {
  // @@protoc_insertion_point(field_get:alisql.CompressedLogEntries.type)
  return _internal_type();
}
inline void CompressedLogEntries::_internal_set_type(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void CompressedLogEntries::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:alisql.CompressedLogEntries.type)
}

// required uint32 rawSize = 2;
inline bool CompressedLogEntries::_internal_has_rawsize() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CompressedLogEntries::has_rawsize() const {
  return _internal_has_rawsize();
}
inline void CompressedLogEntries::clear_rawsize() {
  rawsize_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CompressedLogEntries::_internal_rawsize() const {
  return rawsize_;
}
inline uint32_t CompressedLogEntries::rawsize() const {
  // @@protoc_insertion_point(field_get:alisql.CompressedLogEntries.rawSize)
  return _internal_rawsize();
}
inline void CompressedLogEntries::_internal_set_rawsize(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  rawsize_ = value;
}
inline void CompressedLogEntries::set_rawsize(uint32_t value) {
  _internal_set_rawsize(value);
  // @@protoc_insertion_point(field_set:alisql.CompressedLogEntries.rawSize)
}

// required bytes data = 3;
inline bool CompressedLogEntries::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CompressedLogEntries::has_data() const {
  return _internal_has_data();
}
inline void CompressedLogEntries::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompressedLogEntries::data() const {
  // @@protoc_insertion_point(field_get:alisql.CompressedLogEntries.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompressedLogEntries::set_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alisql.CompressedLogEntries.data)
}
inline std::string* CompressedLogEntries::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:alisql.CompressedLogEntries.data)
  return _s;
}
inline const std::string& CompressedLogEntries::_internal_data() const {
  return data_.Get();
}
inline void CompressedLogEntries::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CompressedLogEntries::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CompressedLogEntries::release_data() {
  // @@protoc_insertion_point(field_release:alisql.CompressedLogEntries.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CompressedLogEntries::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alisql.CompressedLogEntries.data)
}

// optional uint32 checksum = 4;
inline bool CompressedLogEntries::_internal_has_checksum() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CompressedLogEntries::has_checksum() const {
  return _internal_has_checksum();
}
inline void CompressedLogEntries::clear_checksum() {
  checksum_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CompressedLogEntries::_internal_checksum() const {
  return checksum_;
}
inline uint32_t CompressedLogEntries::checksum() const {
  // @@protoc_insertion_point(field_get:alisql.CompressedLogEntries.checksum)
  return _internal_checksum();
}
inline void CompressedLogEntries::_internal_set_checksum(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  checksum_ = value;
}
inline void CompressedLogEntries::set_checksum(uint32_t value) {
  _internal_set_checksum(value);
  // @@protoc_insertion_point(field_set:alisql.CompressedLogEntries.checksum)
}

// -------------------------------------------------------------------

// ConfigureChangeValue

// optional int32 ccType = 1;
inline bool ConfigureChangeValue::_internal_has_cctype() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigureChangeValue::has_cctype() const {
  return _internal_has_cctype();
}
inline void ConfigureChangeValue::clear_cctype() {
  cctype_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t ConfigureChangeValue::_internal_cctype() const {
  return cctype_;
}
inline int32_t ConfigureChangeValue::cctype() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.ccType)
  return _internal_cctype();
}
inline void ConfigureChangeValue::_internal_set_cctype(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  cctype_ = value;
}
inline void ConfigureChangeValue::set_cctype(int32_t value) {
  _internal_set_cctype(value);
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.ccType)
}

// optional int32 opType = 2;
inline bool ConfigureChangeValue::_internal_has_optype() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigureChangeValue::has_optype() const {
  return _internal_has_optype();
}
inline void ConfigureChangeValue::clear_optype() {
  optype_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ConfigureChangeValue::_internal_optype() const {
  return optype_;
}
inline int32_t ConfigureChangeValue::optype() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.opType)
  return _internal_optype();
}
inline void ConfigureChangeValue::_internal_set_optype(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  optype_ = value;
}
inline void ConfigureChangeValue::set_optype(int32_t value) {
  _internal_set_optype(value);
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.opType)
}

// repeated bytes addrs = 3;
inline int ConfigureChangeValue::_internal_addrs_size() const {
  return addrs_.size();
}
inline int ConfigureChangeValue::addrs_size() const {
  return _internal_addrs_size();
}
inline void ConfigureChangeValue::clear_addrs() {
  addrs_.Clear();
}
inline std::string* ConfigureChangeValue::add_addrs() {
  std::string* _s = _internal_add_addrs();
  // @@protoc_insertion_point(field_add_mutable:alisql.ConfigureChangeValue.addrs)
  return _s;
}
inline const std::string& ConfigureChangeValue::_internal_addrs(int index) const {
  return addrs_.Get(index);
}
inline const std::string& ConfigureChangeValue::addrs(int index) const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.addrs)
  return _internal_addrs(index);
}
inline std::string* ConfigureChangeValue::mutable_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:alisql.ConfigureChangeValue.addrs)
  return addrs_.Mutable(index);
}
inline void ConfigureChangeValue::set_addrs(int index, const std::string& value) {
  addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.addrs)
}
inline void ConfigureChangeValue::set_addrs(int index, std::string&& value) {
  addrs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.addrs)
}
inline void ConfigureChangeValue::set_addrs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alisql.ConfigureChangeValue.addrs)
}
inline void ConfigureChangeValue::set_addrs(int index, const void* value, size_t size) {
  addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alisql.ConfigureChangeValue.addrs)
}
inline std::string* ConfigureChangeValue::_internal_add_addrs() {
  return addrs_.Add();
}
inline void ConfigureChangeValue::add_addrs(const std::string& value) {
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alisql.ConfigureChangeValue.addrs)
}
inline void ConfigureChangeValue::add_addrs(std::string&& value) {
  addrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alisql.ConfigureChangeValue.addrs)
}
inline void ConfigureChangeValue::add_addrs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alisql.ConfigureChangeValue.addrs)
}
inline void ConfigureChangeValue::add_addrs(const void* value, size_t size) {
  addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alisql.ConfigureChangeValue.addrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConfigureChangeValue::addrs() const {
  // @@protoc_insertion_point(field_list:alisql.ConfigureChangeValue.addrs)
  return addrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConfigureChangeValue::mutable_addrs() {
  // @@protoc_insertion_point(field_mutable_list:alisql.ConfigureChangeValue.addrs)
  return &addrs_;
}

// repeated bytes allServers = 4;
inline int ConfigureChangeValue::_internal_allservers_size() const {
  return allservers_.size();
}
inline int ConfigureChangeValue::allservers_size() const {
  return _internal_allservers_size();
}
inline void ConfigureChangeValue::clear_allservers() {
  allservers_.Clear();
}
inline std::string* ConfigureChangeValue::add_allservers() {
  std::string* _s = _internal_add_allservers();
  // @@protoc_insertion_point(field_add_mutable:alisql.ConfigureChangeValue.allServers)
  return _s;
}
inline const std::string& ConfigureChangeValue::_internal_allservers(int index) const {
  return allservers_.Get(index);
}
inline const std::string& ConfigureChangeValue::allservers(int index) const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.allServers)
  return _internal_allservers(index);
}
inline std::string* ConfigureChangeValue::mutable_allservers(int index) {
  // @@protoc_insertion_point(field_mutable:alisql.ConfigureChangeValue.allServers)
  return allservers_.Mutable(index);
}
inline void ConfigureChangeValue::set_allservers(int index, const std::string& value) {
  allservers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.allServers)
}
inline void ConfigureChangeValue::set_allservers(int index, std::string&& value) {
  allservers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.allServers)
}
inline void ConfigureChangeValue::set_allservers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  allservers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alisql.ConfigureChangeValue.allServers)
}
inline void ConfigureChangeValue::set_allservers(int index, const void* value, size_t size) {
  allservers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alisql.ConfigureChangeValue.allServers)
}
inline std::string* ConfigureChangeValue::_internal_add_allservers() {
  return allservers_.Add();
}
inline void ConfigureChangeValue::add_allservers(const std::string& value) {
  allservers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alisql.ConfigureChangeValue.allServers)
}
inline void ConfigureChangeValue::add_allservers(std::string&& value) {
  allservers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alisql.ConfigureChangeValue.allServers)
}
inline void ConfigureChangeValue::add_allservers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  allservers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alisql.ConfigureChangeValue.allServers)
}
inline void ConfigureChangeValue::add_allservers(const void* value, size_t size) {
  allservers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alisql.ConfigureChangeValue.allServers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConfigureChangeValue::allservers() const {
  // @@protoc_insertion_point(field_list:alisql.ConfigureChangeValue.allServers)
  return allservers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConfigureChangeValue::mutable_allservers() {
  // @@protoc_insertion_point(field_mutable_list:alisql.ConfigureChangeValue.allServers)
  return &allservers_;
}

// repeated bytes allLearners = 5;
inline int ConfigureChangeValue::_internal_alllearners_size() const {
  return alllearners_.size();
}
inline int ConfigureChangeValue::alllearners_size() const {
  return _internal_alllearners_size();
}
inline void ConfigureChangeValue::clear_alllearners() {
  alllearners_.Clear();
}
inline std::string* ConfigureChangeValue::add_alllearners() {
  std::string* _s = _internal_add_alllearners();
  // @@protoc_insertion_point(field_add_mutable:alisql.ConfigureChangeValue.allLearners)
  return _s;
}
inline const std::string& ConfigureChangeValue::_internal_alllearners(int index) const {
  return alllearners_.Get(index);
}
inline const std::string& ConfigureChangeValue::alllearners(int index) const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.allLearners)
  return _internal_alllearners(index);
}
inline std::string* ConfigureChangeValue::mutable_alllearners(int index) {
  // @@protoc_insertion_point(field_mutable:alisql.ConfigureChangeValue.allLearners)
  return alllearners_.Mutable(index);
}
inline void ConfigureChangeValue::set_alllearners(int index, const std::string& value) {
  alllearners_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.allLearners)
}
inline void ConfigureChangeValue::set_alllearners(int index, std::string&& value) {
  alllearners_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.allLearners)
}
inline void ConfigureChangeValue::set_alllearners(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  alllearners_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alisql.ConfigureChangeValue.allLearners)
}
inline void ConfigureChangeValue::set_alllearners(int index, const void* value, size_t size) {
  alllearners_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alisql.ConfigureChangeValue.allLearners)
}
inline std::string* ConfigureChangeValue::_internal_add_alllearners() {
  return alllearners_.Add();
}
inline void ConfigureChangeValue::add_alllearners(const std::string& value) {
  alllearners_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alisql.ConfigureChangeValue.allLearners)
}
inline void ConfigureChangeValue::add_alllearners(std::string&& value) {
  alllearners_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alisql.ConfigureChangeValue.allLearners)
}
inline void ConfigureChangeValue::add_alllearners(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  alllearners_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alisql.ConfigureChangeValue.allLearners)
}
inline void ConfigureChangeValue::add_alllearners(const void* value, size_t size) {
  alllearners_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alisql.ConfigureChangeValue.allLearners)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConfigureChangeValue::alllearners() const {
  // @@protoc_insertion_point(field_list:alisql.ConfigureChangeValue.allLearners)
  return alllearners_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConfigureChangeValue::mutable_alllearners() {
  // @@protoc_insertion_point(field_mutable_list:alisql.ConfigureChangeValue.allLearners)
  return &alllearners_;
}

// optional uint64 serverId = 6;
inline bool ConfigureChangeValue::_internal_has_serverid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigureChangeValue::has_serverid() const {
  return _internal_has_serverid();
}
inline void ConfigureChangeValue::clear_serverid() {
  serverid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t ConfigureChangeValue::_internal_serverid() const {
  return serverid_;
}
inline uint64_t ConfigureChangeValue::serverid() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.serverId)
  return _internal_serverid();
}
inline void ConfigureChangeValue::_internal_set_serverid(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  serverid_ = value;
}
inline void ConfigureChangeValue::set_serverid(uint64_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.serverId)
}

// optional uint32 forceSync = 7;
inline bool ConfigureChangeValue::_internal_has_forcesync() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigureChangeValue::has_forcesync() const {
  return _internal_has_forcesync();
}
inline void ConfigureChangeValue::clear_forcesync() {
  forcesync_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ConfigureChangeValue::_internal_forcesync() const {
  return forcesync_;
}
inline uint32_t ConfigureChangeValue::forcesync() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.forceSync)
  return _internal_forcesync();
}
inline void ConfigureChangeValue::_internal_set_forcesync(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  forcesync_ = value;
}
inline void ConfigureChangeValue::set_forcesync(uint32_t value) {
  _internal_set_forcesync(value);
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.forceSync)
}

// optional uint32 electionWeight = 8;
inline bool ConfigureChangeValue::_internal_has_electionweight() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigureChangeValue::has_electionweight() const {
  return _internal_has_electionweight();
}
inline void ConfigureChangeValue::clear_electionweight() {
  electionweight_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ConfigureChangeValue::_internal_electionweight() const {
  return electionweight_;
}
inline uint32_t ConfigureChangeValue::electionweight() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.electionWeight)
  return _internal_electionweight();
}
inline void ConfigureChangeValue::_internal_set_electionweight(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  electionweight_ = value;
}
inline void ConfigureChangeValue::set_electionweight(uint32_t value) {
  _internal_set_electionweight(value);
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.electionWeight)
}

// optional uint64 learnerSource = 9;
inline bool ConfigureChangeValue::_internal_has_learnersource() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigureChangeValue::has_learnersource() const {
  return _internal_has_learnersource();
}
inline void ConfigureChangeValue::clear_learnersource() {
  learnersource_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t ConfigureChangeValue::_internal_learnersource() const {
  return learnersource_;
}
inline uint64_t ConfigureChangeValue::learnersource() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.learnerSource)
  return _internal_learnersource();
}
inline void ConfigureChangeValue::_internal_set_learnersource(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  learnersource_ = value;
}
inline void ConfigureChangeValue::set_learnersource(uint64_t value) {
  _internal_set_learnersource(value);
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.learnerSource)
}

// optional bool applyMode = 10;
inline bool ConfigureChangeValue::_internal_has_applymode() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigureChangeValue::has_applymode() const {
  return _internal_has_applymode();
}
inline void ConfigureChangeValue::clear_applymode() {
  applymode_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ConfigureChangeValue::_internal_applymode() const {
  return applymode_;
}
inline bool ConfigureChangeValue::applymode() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.applyMode)
  return _internal_applymode();
}
inline void ConfigureChangeValue::_internal_set_applymode(bool value) {
  _has_bits_[0] |= 0x00000040u;
  applymode_ = value;
}
inline void ConfigureChangeValue::set_applymode(bool value) {
  _internal_set_applymode(value);
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.applyMode)
}

// -------------------------------------------------------------------

// ClusterInfoEntry

// required uint64 serverId = 1;
inline bool ClusterInfoEntry::_internal_has_serverid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClusterInfoEntry::has_serverid() const {
  return _internal_has_serverid();
}
inline void ClusterInfoEntry::clear_serverid() {
  serverid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ClusterInfoEntry::_internal_serverid() const {
  return serverid_;
}
inline uint64_t ClusterInfoEntry::serverid() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.serverId)
  return _internal_serverid();
}
inline void ClusterInfoEntry::_internal_set_serverid(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  serverid_ = value;
}
inline void ClusterInfoEntry::set_serverid(uint64_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.serverId)
}

// optional uint64 matchIndex = 2;
inline bool ClusterInfoEntry::_internal_has_matchindex() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClusterInfoEntry::has_matchindex() const {
  return _internal_has_matchindex();
}
inline void ClusterInfoEntry::clear_matchindex() {
  matchindex_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t ClusterInfoEntry::_internal_matchindex() const {
  return matchindex_;
}
inline uint64_t ClusterInfoEntry::matchindex() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.matchIndex)
  return _internal_matchindex();
}
inline void ClusterInfoEntry::_internal_set_matchindex(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  matchindex_ = value;
}
inline void ClusterInfoEntry::set_matchindex(uint64_t value) {
  _internal_set_matchindex(value);
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.matchIndex)
}

// optional uint64 nextIndex = 3;
inline bool ClusterInfoEntry::_internal_has_nextindex() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClusterInfoEntry::has_nextindex() const {
  return _internal_has_nextindex();
}
inline void ClusterInfoEntry::clear_nextindex() {
  nextindex_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t ClusterInfoEntry::_internal_nextindex() const {
  return nextindex_;
}
inline uint64_t ClusterInfoEntry::nextindex() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.nextIndex)
  return _internal_nextindex();
}
inline void ClusterInfoEntry::_internal_set_nextindex(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  nextindex_ = value;
}
inline void ClusterInfoEntry::set_nextindex(uint64_t value) {
  _internal_set_nextindex(value);
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.nextIndex)
}

// optional uint32 role = 4;
inline bool ClusterInfoEntry::_internal_has_role() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ClusterInfoEntry::has_role() const {
  return _internal_has_role();
}
inline void ClusterInfoEntry::clear_role() {
  role_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ClusterInfoEntry::_internal_role() const {
  return role_;
}
inline uint32_t ClusterInfoEntry::role() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.role)
  return _internal_role();
}
inline void ClusterInfoEntry::_internal_set_role(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  role_ = value;
}
inline void ClusterInfoEntry::set_role(uint32_t value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.role)
}

// optional uint64 hasVoted = 5;
inline bool ClusterInfoEntry::_internal_has_hasvoted() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ClusterInfoEntry::has_hasvoted() const {
  return _internal_has_hasvoted();
}
inline void ClusterInfoEntry::clear_hasvoted() {
  hasvoted_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t ClusterInfoEntry::_internal_hasvoted() const {
  return hasvoted_;
}
inline uint64_t ClusterInfoEntry::hasvoted() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.hasVoted)
  return _internal_hasvoted();
}
inline void ClusterInfoEntry::_internal_set_hasvoted(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  hasvoted_ = value;
}
inline void ClusterInfoEntry::set_hasvoted(uint64_t value) {
  _internal_set_hasvoted(value);
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.hasVoted)
}

// optional uint32 forceSync = 6;
inline bool ClusterInfoEntry::_internal_has_forcesync() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ClusterInfoEntry::has_forcesync() const {
  return _internal_has_forcesync();
}
inline void ClusterInfoEntry::clear_forcesync() {
  forcesync_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ClusterInfoEntry::_internal_forcesync() const {
  return forcesync_;
}
inline uint32_t ClusterInfoEntry::forcesync() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.forceSync)
  return _internal_forcesync();
}
inline void ClusterInfoEntry::_internal_set_forcesync(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  forcesync_ = value;
}
inline void ClusterInfoEntry::set_forcesync(uint32_t value) {
  _internal_set_forcesync(value);
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.forceSync)
}

// optional uint32 electionWeight = 7;
inline bool ClusterInfoEntry::_internal_has_electionweight() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ClusterInfoEntry::has_electionweight() const {
  return _internal_has_electionweight();
}
inline void ClusterInfoEntry::clear_electionweight() {
  electionweight_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t ClusterInfoEntry::_internal_electionweight() const {
  return electionweight_;
}
inline uint32_t ClusterInfoEntry::electionweight() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.electionWeight)
  return _internal_electionweight();
}
inline void ClusterInfoEntry::_internal_set_electionweight(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  electionweight_ = value;
}
inline void ClusterInfoEntry::set_electionweight(uint32_t value) {
  _internal_set_electionweight(value);
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.electionWeight)
}

// optional uint64 learnerSource = 8;
inline bool ClusterInfoEntry::_internal_has_learnersource() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ClusterInfoEntry::has_learnersource() const {
  return _internal_has_learnersource();
}
inline void ClusterInfoEntry::clear_learnersource() {
  learnersource_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t ClusterInfoEntry::_internal_learnersource() const {
  return learnersource_;
}
inline uint64_t ClusterInfoEntry::learnersource() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.learnerSource)
  return _internal_learnersource();
}
inline void ClusterInfoEntry::_internal_set_learnersource(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  learnersource_ = value;
}
inline void ClusterInfoEntry::set_learnersource(uint64_t value) {
  _internal_set_learnersource(value);
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.learnerSource)
}

// optional uint64 appliedIndex = 9;
inline bool ClusterInfoEntry::_internal_has_appliedindex() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ClusterInfoEntry::has_appliedindex() const {
  return _internal_has_appliedindex();
}
inline void ClusterInfoEntry::clear_appliedindex() {
  appliedindex_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000200u;
}
inline uint64_t ClusterInfoEntry::_internal_appliedindex() const {
  return appliedindex_;
}
inline uint64_t ClusterInfoEntry::appliedindex() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.appliedIndex)
  return _internal_appliedindex();
}
inline void ClusterInfoEntry::_internal_set_appliedindex(uint64_t value) {
  _has_bits_[0] |= 0x00000200u;
  appliedindex_ = value;
}
inline void ClusterInfoEntry::set_appliedindex(uint64_t value) {
  _internal_set_appliedindex(value);
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.appliedIndex)
}

// optional uint32 pipelining = 10;
inline bool ClusterInfoEntry::_internal_has_pipelining() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ClusterInfoEntry::has_pipelining() const {
  return _internal_has_pipelining();
}
inline void ClusterInfoEntry::clear_pipelining() {
  pipelining_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t ClusterInfoEntry::_internal_pipelining() const {
  return pipelining_;
}
inline uint32_t ClusterInfoEntry::pipelining() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.pipelining)
  return _internal_pipelining();
}
inline void ClusterInfoEntry::_internal_set_pipelining(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  pipelining_ = value;
}
inline void ClusterInfoEntry::set_pipelining(uint32_t value) {
  _internal_set_pipelining(value);
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.pipelining)
}

// -------------------------------------------------------------------

// PaxosMsg

// optional uint64 configId = 1;
inline bool PaxosMsg::_internal_has_configid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PaxosMsg::has_configid() const {
  return _internal_has_configid();
}
inline void PaxosMsg::clear_configid() {
  configid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t PaxosMsg::_internal_configid() const {
  return configid_;
}
inline uint64_t PaxosMsg::configid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.configId)
  return _internal_configid();
}
inline void PaxosMsg::_internal_set_configid(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  configid_ = value;
}
inline void PaxosMsg::set_configid(uint64_t value) {
  _internal_set_configid(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.configId)
}

// required uint64 clusterId = 2;
inline bool PaxosMsg::_internal_has_clusterid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PaxosMsg::has_clusterid() const {
  return _internal_has_clusterid();
}
inline void PaxosMsg::clear_clusterid() {
  clusterid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t PaxosMsg::_internal_clusterid() const {
  return clusterid_;
}
inline uint64_t PaxosMsg::clusterid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.clusterId)
  return _internal_clusterid();
}
inline void PaxosMsg::_internal_set_clusterid(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  clusterid_ = value;
}
inline void PaxosMsg::set_clusterid(uint64_t value) {
  _internal_set_clusterid(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.clusterId)
}

// required uint64 serverId = 3;
inline bool PaxosMsg::_internal_has_serverid() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PaxosMsg::has_serverid() const {
  return _internal_has_serverid();
}
inline void PaxosMsg::clear_serverid() {
  serverid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t PaxosMsg::_internal_serverid() const {
  return serverid_;
}
inline uint64_t PaxosMsg::serverid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.serverId)
  return _internal_serverid();
}
inline void PaxosMsg::_internal_set_serverid(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  serverid_ = value;
}
inline void PaxosMsg::set_serverid(uint64_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.serverId)
}

// required int32 msgType = 4;
inline bool PaxosMsg::_internal_has_msgtype() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool PaxosMsg::has_msgtype() const {
  return _internal_has_msgtype();
}
inline void PaxosMsg::clear_msgtype() {
  msgtype_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline int32_t PaxosMsg::_internal_msgtype() const {
  return msgtype_;
}
inline int32_t PaxosMsg::msgtype() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.msgType)
  return _internal_msgtype();
}
inline void PaxosMsg::_internal_set_msgtype(int32_t value) {
  _has_bits_[0] |= 0x00001000u;
  msgtype_ = value;
}
inline void PaxosMsg::set_msgtype(int32_t value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.msgType)
}

// required uint64 term = 5;
inline bool PaxosMsg::_internal_has_term() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PaxosMsg::has_term() const {
  return _internal_has_term();
}
inline void PaxosMsg::clear_term() {
  term_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t PaxosMsg::_internal_term() const {
  return term_;
}
inline uint64_t PaxosMsg::term() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.term)
  return _internal_term();
}
inline void PaxosMsg::_internal_set_term(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  term_ = value;
}
inline void PaxosMsg::set_term(uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.term)
}

// required uint64 msgId = 6;
inline bool PaxosMsg::_internal_has_msgid() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PaxosMsg::has_msgid() const {
  return _internal_has_msgid();
}
inline void PaxosMsg::clear_msgid() {
  msgid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000080u;
}
inline uint64_t PaxosMsg::_internal_msgid() const {
  return msgid_;
}
inline uint64_t PaxosMsg::msgid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.msgId)
  return _internal_msgid();
}
inline void PaxosMsg::_internal_set_msgid(uint64_t value) {
  _has_bits_[0] |= 0x00000080u;
  msgid_ = value;
}
inline void PaxosMsg::set_msgid(uint64_t value) {
  _internal_set_msgid(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.msgId)
}

// optional uint64 leaderId = 7;
inline bool PaxosMsg::_internal_has_leaderid() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PaxosMsg::has_leaderid() const {
  return _internal_has_leaderid();
}
inline void PaxosMsg::clear_leaderid() {
  leaderid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000100u;
}
inline uint64_t PaxosMsg::_internal_leaderid() const {
  return leaderid_;
}
inline uint64_t PaxosMsg::leaderid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.leaderId)
  return _internal_leaderid();
}
inline void PaxosMsg::_internal_set_leaderid(uint64_t value) {
  _has_bits_[0] |= 0x00000100u;
  leaderid_ = value;
}
inline void PaxosMsg::set_leaderid(uint64_t value) {
  _internal_set_leaderid(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.leaderId)
}

// optional uint64 prevLogIndex = 8;
inline bool PaxosMsg::_internal_has_prevlogindex() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PaxosMsg::has_prevlogindex() const {
  return _internal_has_prevlogindex();
}
inline void PaxosMsg::clear_prevlogindex() {
  prevlogindex_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000200u;
}
inline uint64_t PaxosMsg::_internal_prevlogindex() const {
  return prevlogindex_;
}
inline uint64_t PaxosMsg::prevlogindex() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.prevLogIndex)
  return _internal_prevlogindex();
}
inline void PaxosMsg::_internal_set_prevlogindex(uint64_t value) {
  _has_bits_[0] |= 0x00000200u;
  prevlogindex_ = value;
}
inline void PaxosMsg::set_prevlogindex(uint64_t value) {
  _internal_set_prevlogindex(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.prevLogIndex)
}

// optional uint64 prevLogTerm = 9;
inline bool PaxosMsg::_internal_has_prevlogterm() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool PaxosMsg::has_prevlogterm() const {
  return _internal_has_prevlogterm();
}
inline void PaxosMsg::clear_prevlogterm() {
  prevlogterm_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000400u;
}
inline uint64_t PaxosMsg::_internal_prevlogterm() const {
  return prevlogterm_;
}
inline uint64_t PaxosMsg::prevlogterm() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.prevLogTerm)
  return _internal_prevlogterm();
}
inline void PaxosMsg::_internal_set_prevlogterm(uint64_t value) {
  _has_bits_[0] |= 0x00000400u;
  prevlogterm_ = value;
}
inline void PaxosMsg::set_prevlogterm(uint64_t value) {
  _internal_set_prevlogterm(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.prevLogTerm)
}

// repeated .alisql.LogEntry entries = 10;
inline int PaxosMsg::_internal_entries_size() const {
  return entries_.size();
}
inline int PaxosMsg::entries_size() const {
  return _internal_entries_size();
}
inline void PaxosMsg::clear_entries() {
  entries_.Clear();
}
inline ::alisql::LogEntry* PaxosMsg::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:alisql.PaxosMsg.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alisql::LogEntry >*
PaxosMsg::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:alisql.PaxosMsg.entries)
  return &entries_;
}
inline const ::alisql::LogEntry& PaxosMsg::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::alisql::LogEntry& PaxosMsg::entries(int index) const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.entries)
  return _internal_entries(index);
}
inline ::alisql::LogEntry* PaxosMsg::_internal_add_entries() {
  return entries_.Add();
}
inline ::alisql::LogEntry* PaxosMsg::add_entries() {
  ::alisql::LogEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:alisql.PaxosMsg.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alisql::LogEntry >&
PaxosMsg::entries() const {
  // @@protoc_insertion_point(field_list:alisql.PaxosMsg.entries)
  return entries_;
}

// optional uint64 commitIndex = 11;
inline bool PaxosMsg::_internal_has_commitindex() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool PaxosMsg::has_commitindex() const {
  return _internal_has_commitindex();
}
inline void PaxosMsg::clear_commitindex() {
  commitindex_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000800u;
}
inline uint64_t PaxosMsg::_internal_commitindex() const {
  return commitindex_;
}
inline uint64_t PaxosMsg::commitindex() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.commitIndex)
  return _internal_commitindex();
}
inline void PaxosMsg::_internal_set_commitindex(uint64_t value) {
  _has_bits_[0] |= 0x00000800u;
  commitindex_ = value;
}
inline void PaxosMsg::set_commitindex(uint64_t value) {
  _internal_set_commitindex(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.commitIndex)
}

// optional bool nocache = 12;
inline bool PaxosMsg::_internal_has_nocache() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool PaxosMsg::has_nocache() const {
  return _internal_has_nocache();
}
inline void PaxosMsg::clear_nocache() {
  nocache_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool PaxosMsg::_internal_nocache() const {
  return nocache_;
}
inline bool PaxosMsg::nocache() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.nocache)
  return _internal_nocache();
}
inline void PaxosMsg::_internal_set_nocache(bool value) {
  _has_bits_[0] |= 0x00002000u;
  nocache_ = value;
}
inline void PaxosMsg::set_nocache(bool value) {
  _internal_set_nocache(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.nocache)
}

// optional bool isSuccess = 13;
inline bool PaxosMsg::_internal_has_issuccess() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool PaxosMsg::has_issuccess() const {
  return _internal_has_issuccess();
}
inline void PaxosMsg::clear_issuccess() {
  issuccess_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool PaxosMsg::_internal_issuccess() const {
  return issuccess_;
}
inline bool PaxosMsg::issuccess() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.isSuccess)
  return _internal_issuccess();
}
inline void PaxosMsg::_internal_set_issuccess(bool value) {
  _has_bits_[0] |= 0x00004000u;
  issuccess_ = value;
}
inline void PaxosMsg::set_issuccess(bool value) {
  _internal_set_issuccess(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.isSuccess)
}

// optional uint64 candidateId = 14;
inline bool PaxosMsg::_internal_has_candidateid() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool PaxosMsg::has_candidateid() const {
  return _internal_has_candidateid();
}
inline void PaxosMsg::clear_candidateid() {
  candidateid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00020000u;
}
inline uint64_t PaxosMsg::_internal_candidateid() const {
  return candidateid_;
}
inline uint64_t PaxosMsg::candidateid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.candidateId)
  return _internal_candidateid();
}
inline void PaxosMsg::_internal_set_candidateid(uint64_t value) {
  _has_bits_[0] |= 0x00020000u;
  candidateid_ = value;
}
inline void PaxosMsg::set_candidateid(uint64_t value) {
  _internal_set_candidateid(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.candidateId)
}

// optional uint64 lastLogIndex = 15;
inline bool PaxosMsg::_internal_has_lastlogindex() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool PaxosMsg::has_lastlogindex() const {
  return _internal_has_lastlogindex();
}
inline void PaxosMsg::clear_lastlogindex() {
  lastlogindex_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00040000u;
}
inline uint64_t PaxosMsg::_internal_lastlogindex() const {
  return lastlogindex_;
}
inline uint64_t PaxosMsg::lastlogindex() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.lastLogIndex)
  return _internal_lastlogindex();
}
inline void PaxosMsg::_internal_set_lastlogindex(uint64_t value) {
  _has_bits_[0] |= 0x00040000u;
  lastlogindex_ = value;
}
inline void PaxosMsg::set_lastlogindex(uint64_t value) {
  _internal_set_lastlogindex(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.lastLogIndex)
}

// optional uint64 lastLogTerm = 16;
inline bool PaxosMsg::_internal_has_lastlogterm() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool PaxosMsg::has_lastlogterm() const {
  return _internal_has_lastlogterm();
}
inline void PaxosMsg::clear_lastlogterm() {
  lastlogterm_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00080000u;
}
inline uint64_t PaxosMsg::_internal_lastlogterm() const {
  return lastlogterm_;
}
inline uint64_t PaxosMsg::lastlogterm() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.lastLogTerm)
  return _internal_lastlogterm();
}
inline void PaxosMsg::_internal_set_lastlogterm(uint64_t value) {
  _has_bits_[0] |= 0x00080000u;
  lastlogterm_ = value;
}
inline void PaxosMsg::set_lastlogterm(uint64_t value) {
  _internal_set_lastlogterm(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.lastLogTerm)
}

// optional uint64 force = 17;
inline bool PaxosMsg::_internal_has_force() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool PaxosMsg::has_force() const {
  return _internal_has_force();
}
inline void PaxosMsg::clear_force() {
  force_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00100000u;
}
inline uint64_t PaxosMsg::_internal_force() const {
  return force_;
}
inline uint64_t PaxosMsg::force() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.force)
  return _internal_force();
}
inline void PaxosMsg::_internal_set_force(uint64_t value) {
  _has_bits_[0] |= 0x00100000u;
  force_ = value;
}
inline void PaxosMsg::set_force(uint64_t value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.force)
}

// optional bytes addr = 18;
inline bool PaxosMsg::_internal_has_addr() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PaxosMsg::has_addr() const {
  return _internal_has_addr();
}
inline void PaxosMsg::clear_addr() {
  addr_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PaxosMsg::addr() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaxosMsg::set_addr(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 addr_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.addr)
}
inline std::string* PaxosMsg::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:alisql.PaxosMsg.addr)
  return _s;
}
inline const std::string& PaxosMsg::_internal_addr() const {
  return addr_.Get();
}
inline void PaxosMsg::_internal_set_addr(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PaxosMsg::_internal_mutable_addr() {
  _has_bits_[0] |= 0x00000001u;
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PaxosMsg::release_addr() {
  // @@protoc_insertion_point(field_release:alisql.PaxosMsg.addr)
  if (!_internal_has_addr()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = addr_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaxosMsg::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alisql.PaxosMsg.addr)
}

// optional bool voteGranted = 19;
inline bool PaxosMsg::_internal_has_votegranted() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool PaxosMsg::has_votegranted() const {
  return _internal_has_votegranted();
}
inline void PaxosMsg::clear_votegranted() {
  votegranted_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool PaxosMsg::_internal_votegranted() const {
  return votegranted_;
}
inline bool PaxosMsg::votegranted() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.voteGranted)
  return _internal_votegranted();
}
inline void PaxosMsg::_internal_set_votegranted(bool value) {
  _has_bits_[0] |= 0x00008000u;
  votegranted_ = value;
}
inline void PaxosMsg::set_votegranted(bool value) {
  _internal_set_votegranted(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.voteGranted)
}

// optional bool ignoreCheck = 20;
inline bool PaxosMsg::_internal_has_ignorecheck() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool PaxosMsg::has_ignorecheck() const {
  return _internal_has_ignorecheck();
}
inline void PaxosMsg::clear_ignorecheck() {
  ignorecheck_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool PaxosMsg::_internal_ignorecheck() const {
  return ignorecheck_;
}
inline bool PaxosMsg::ignorecheck() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.ignoreCheck)
  return _internal_ignorecheck();
}
inline void PaxosMsg::_internal_set_ignorecheck(bool value) {
  _has_bits_[0] |= 0x00010000u;
  ignorecheck_ = value;
}
inline void PaxosMsg::set_ignorecheck(bool value) {
  _internal_set_ignorecheck(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.ignoreCheck)
}

// optional uint64 lcType = 21;
inline bool PaxosMsg::_internal_has_lctype() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool PaxosMsg::has_lctype() const {
  return _internal_has_lctype();
}
inline void PaxosMsg::clear_lctype() {
  lctype_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00200000u;
}
inline uint64_t PaxosMsg::_internal_lctype() const {
  return lctype_;
}
inline uint64_t PaxosMsg::lctype() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.lcType)
  return _internal_lctype();
}
inline void PaxosMsg::_internal_set_lctype(uint64_t value) {
  _has_bits_[0] |= 0x00200000u;
  lctype_ = value;
}
inline void PaxosMsg::set_lctype(uint64_t value) {
  _internal_set_lctype(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.lcType)
}

// optional uint64 minMatchIndex = 22;
inline bool PaxosMsg::_internal_has_minmatchindex() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool PaxosMsg::has_minmatchindex() const {
  return _internal_has_minmatchindex();
}
inline void PaxosMsg::clear_minmatchindex() {
  minmatchindex_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00400000u;
}
inline uint64_t PaxosMsg::_internal_minmatchindex() const {
  return minmatchindex_;
}
inline uint64_t PaxosMsg::minmatchindex() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.minMatchIndex)
  return _internal_minmatchindex();
}
inline void PaxosMsg::_internal_set_minmatchindex(uint64_t value) {
  _has_bits_[0] |= 0x00400000u;
  minmatchindex_ = value;
}
inline void PaxosMsg::set_minmatchindex(uint64_t value) {
  _internal_set_minmatchindex(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.minMatchIndex)
}

// optional uint64 appliedIndex = 23;
inline bool PaxosMsg::_internal_has_appliedindex() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool PaxosMsg::has_appliedindex() const {
  return _internal_has_appliedindex();
}
inline void PaxosMsg::clear_appliedindex() {
  appliedindex_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00800000u;
}
inline uint64_t PaxosMsg::_internal_appliedindex() const {
  return appliedindex_;
}
inline uint64_t PaxosMsg::appliedindex() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.appliedIndex)
  return _internal_appliedindex();
}
inline void PaxosMsg::_internal_set_appliedindex(uint64_t value) {
  _has_bits_[0] |= 0x00800000u;
  appliedindex_ = value;
}
inline void PaxosMsg::set_appliedindex(uint64_t value) {
  _internal_set_appliedindex(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.appliedIndex)
}

// optional uint64 newClusterId = 24;
inline bool PaxosMsg::_internal_has_newclusterid() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool PaxosMsg::has_newclusterid() const {
  return _internal_has_newclusterid();
}
inline void PaxosMsg::clear_newclusterid() {
  newclusterid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x01000000u;
}
inline uint64_t PaxosMsg::_internal_newclusterid() const {
  return newclusterid_;
}
inline uint64_t PaxosMsg::newclusterid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.newClusterId)
  return _internal_newclusterid();
}
inline void PaxosMsg::_internal_set_newclusterid(uint64_t value) {
  _has_bits_[0] |= 0x01000000u;
  newclusterid_ = value;
}
inline void PaxosMsg::set_newclusterid(uint64_t value) {
  _internal_set_newclusterid(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.newClusterId)
}

// repeated .alisql.ClusterInfoEntry ciEntries = 25;
inline int PaxosMsg::_internal_cientries_size() const {
  return cientries_.size();
}
inline int PaxosMsg::cientries_size() const {
  return _internal_cientries_size();
}
inline void PaxosMsg::clear_cientries() {
  cientries_.Clear();
}
inline ::alisql::ClusterInfoEntry* PaxosMsg::mutable_cientries(int index) {
  // @@protoc_insertion_point(field_mutable:alisql.PaxosMsg.ciEntries)
  return cientries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alisql::ClusterInfoEntry >*
PaxosMsg::mutable_cientries() {
  // @@protoc_insertion_point(field_mutable_list:alisql.PaxosMsg.ciEntries)
  return &cientries_;
}
inline const ::alisql::ClusterInfoEntry& PaxosMsg::_internal_cientries(int index) const {
  return cientries_.Get(index);
}
inline const ::alisql::ClusterInfoEntry& PaxosMsg::cientries(int index) const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.ciEntries)
  return _internal_cientries(index);
}
inline ::alisql::ClusterInfoEntry* PaxosMsg::_internal_add_cientries() {
  return cientries_.Add();
}
inline ::alisql::ClusterInfoEntry* PaxosMsg::add_cientries() {
  ::alisql::ClusterInfoEntry* _add = _internal_add_cientries();
  // @@protoc_insertion_point(field_add:alisql.PaxosMsg.ciEntries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alisql::ClusterInfoEntry >&
PaxosMsg::cientries() const {
  // @@protoc_insertion_point(field_list:alisql.PaxosMsg.ciEntries)
  return cientries_;
}

// optional uint32 role = 26;
inline bool PaxosMsg::_internal_has_role() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool PaxosMsg::has_role() const {
  return _internal_has_role();
}
inline void PaxosMsg::clear_role() {
  role_ = 0u;
  _has_bits_[0] &= ~0x02000000u;
}
inline uint32_t PaxosMsg::_internal_role() const {
  return role_;
}
inline uint32_t PaxosMsg::role() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.role)
  return _internal_role();
}
inline void PaxosMsg::_internal_set_role(uint32_t value) {
  _has_bits_[0] |= 0x02000000u;
  role_ = value;
}
inline void PaxosMsg::set_role(uint32_t value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.role)
}

// optional .alisql.CompressedLogEntries compressedEntries = 27;
inline bool PaxosMsg::_internal_has_compressedentries() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || compressedentries_ != nullptr);
  return value;
}
inline bool PaxosMsg::has_compressedentries() const {
  return _internal_has_compressedentries();
}
inline void PaxosMsg::clear_compressedentries() {
  if (compressedentries_ != nullptr) compressedentries_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::alisql::CompressedLogEntries& PaxosMsg::_internal_compressedentries() const {
  const ::alisql::CompressedLogEntries* p = compressedentries_;
  return p != nullptr ? *p : reinterpret_cast<const ::alisql::CompressedLogEntries&>(
      ::alisql::_CompressedLogEntries_default_instance_);
}
inline const ::alisql::CompressedLogEntries& PaxosMsg::compressedentries() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.compressedEntries)
  return _internal_compressedentries();
}
inline void PaxosMsg::unsafe_arena_set_allocated_compressedentries(
    ::alisql::CompressedLogEntries* compressedentries) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compressedentries_);
  }
  compressedentries_ = compressedentries;
  if (compressedentries) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alisql.PaxosMsg.compressedEntries)
}
inline ::alisql::CompressedLogEntries* PaxosMsg::release_compressedentries() {
  _has_bits_[0] &= ~0x00000004u;
  ::alisql::CompressedLogEntries* temp = compressedentries_;
  compressedentries_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::alisql::CompressedLogEntries* PaxosMsg::unsafe_arena_release_compressedentries() {
  // @@protoc_insertion_point(field_release:alisql.PaxosMsg.compressedEntries)
  _has_bits_[0] &= ~0x00000004u;
  ::alisql::CompressedLogEntries* temp = compressedentries_;
  compressedentries_ = nullptr;
  return temp;
}
inline ::alisql::CompressedLogEntries* PaxosMsg::_internal_mutable_compressedentries() {
  _has_bits_[0] |= 0x00000004u;
  if (compressedentries_ == nullptr) {
    auto* p = CreateMaybeMessage<::alisql::CompressedLogEntries>(GetArenaForAllocation());
    compressedentries_ = p;
  }
  return compressedentries_;
}
inline ::alisql::CompressedLogEntries* PaxosMsg::mutable_compressedentries() {
  ::alisql::CompressedLogEntries* _msg = _internal_mutable_compressedentries();
  // @@protoc_insertion_point(field_mutable:alisql.PaxosMsg.compressedEntries)
  return _msg;
}
inline void PaxosMsg::set_allocated_compressedentries(::alisql::CompressedLogEntries* compressedentries) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete compressedentries_;
  }
  if (compressedentries) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::alisql::CompressedLogEntries>::GetOwningArena(compressedentries);
    if (message_arena != submessage_arena) {
      compressedentries = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compressedentries, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  compressedentries_ = compressedentries;
  // @@protoc_insertion_point(field_set_allocated:alisql.PaxosMsg.compressedEntries)
}

// optional bytes extra = 28;
inline bool PaxosMsg::_internal_has_extra() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PaxosMsg::has_extra() const {
  return _internal_has_extra();
}
inline void PaxosMsg::clear_extra() {
  extra_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PaxosMsg::extra() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.extra)
  return _internal_extra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaxosMsg::set_extra(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 extra_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.extra)
}
inline std::string* PaxosMsg::mutable_extra() {
  std::string* _s = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:alisql.PaxosMsg.extra)
  return _s;
}
inline const std::string& PaxosMsg::_internal_extra() const {
  return extra_.Get();
}
inline void PaxosMsg::_internal_set_extra(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  extra_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PaxosMsg::_internal_mutable_extra() {
  _has_bits_[0] |= 0x00000002u;
  return extra_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PaxosMsg::release_extra() {
  // @@protoc_insertion_point(field_release:alisql.PaxosMsg.extra)
  if (!_internal_has_extra()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = extra_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    extra_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaxosMsg::set_allocated_extra(std::string* extra) {
  if (extra != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  extra_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extra,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    extra_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alisql.PaxosMsg.extra)
}

// optional .alisql.PaxosMsg.MsgErrorType msgError = 30;
inline bool PaxosMsg::_internal_has_msgerror() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool PaxosMsg::has_msgerror() const {
  return _internal_has_msgerror();
}
inline void PaxosMsg::clear_msgerror() {
  msgerror_ = 0;
  _has_bits_[0] &= ~0x04000000u;
}
inline ::alisql::PaxosMsg_MsgErrorType PaxosMsg::_internal_msgerror() const {
  return static_cast< ::alisql::PaxosMsg_MsgErrorType >(msgerror_);
}
inline ::alisql::PaxosMsg_MsgErrorType PaxosMsg::msgerror() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.msgError)
  return _internal_msgerror();
}
inline void PaxosMsg::_internal_set_msgerror(::alisql::PaxosMsg_MsgErrorType value) {
  assert(::alisql::PaxosMsg_MsgErrorType_IsValid(value));
  _has_bits_[0] |= 0x04000000u;
  msgerror_ = value;
}
inline void PaxosMsg::set_msgerror(::alisql::PaxosMsg_MsgErrorType value) {
  _internal_set_msgerror(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.msgError)
}

// optional uint64 myServerId = 31;
inline bool PaxosMsg::_internal_has_myserverid() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool PaxosMsg::has_myserverid() const {
  return _internal_has_myserverid();
}
inline void PaxosMsg::clear_myserverid() {
  myserverid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x08000000u;
}
inline uint64_t PaxosMsg::_internal_myserverid() const {
  return myserverid_;
}
inline uint64_t PaxosMsg::myserverid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.myServerId)
  return _internal_myserverid();
}
inline void PaxosMsg::_internal_set_myserverid(uint64_t value) {
  _has_bits_[0] |= 0x08000000u;
  myserverid_ = value;
}
inline void PaxosMsg::set_myserverid(uint64_t value) {
  _internal_set_myserverid(value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.myServerId)
}

// -------------------------------------------------------------------

// TestMsg1

// required uint64 id = 1;
inline bool TestMsg1::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMsg1::has_id() const {
  return _internal_has_id();
}
inline void TestMsg1::clear_id() {
  id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t TestMsg1::_internal_id() const {
  return id_;
}
inline uint64_t TestMsg1::id() const {
  // @@protoc_insertion_point(field_get:alisql.TestMsg1.id)
  return _internal_id();
}
inline void TestMsg1::_internal_set_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void TestMsg1::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:alisql.TestMsg1.id)
}

// optional uint64 c1 = 2;
inline bool TestMsg1::_internal_has_c1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TestMsg1::has_c1() const {
  return _internal_has_c1();
}
inline void TestMsg1::clear_c1() {
  c1_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t TestMsg1::_internal_c1() const {
  return c1_;
}
inline uint64_t TestMsg1::c1() const {
  // @@protoc_insertion_point(field_get:alisql.TestMsg1.c1)
  return _internal_c1();
}
inline void TestMsg1::_internal_set_c1(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  c1_ = value;
}
inline void TestMsg1::set_c1(uint64_t value) {
  _internal_set_c1(value);
  // @@protoc_insertion_point(field_set:alisql.TestMsg1.c1)
}

// -------------------------------------------------------------------

// TestMsg2

// required uint64 id = 1;
inline bool TestMsg2::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMsg2::has_id() const {
  return _internal_has_id();
}
inline void TestMsg2::clear_id() {
  id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t TestMsg2::_internal_id() const {
  return id_;
}
inline uint64_t TestMsg2::id() const {
  // @@protoc_insertion_point(field_get:alisql.TestMsg2.id)
  return _internal_id();
}
inline void TestMsg2::_internal_set_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void TestMsg2::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:alisql.TestMsg2.id)
}

// optional uint64 c1 = 2;
inline bool TestMsg2::_internal_has_c1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TestMsg2::has_c1() const {
  return _internal_has_c1();
}
inline void TestMsg2::clear_c1() {
  c1_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t TestMsg2::_internal_c1() const {
  return c1_;
}
inline uint64_t TestMsg2::c1() const {
  // @@protoc_insertion_point(field_get:alisql.TestMsg2.c1)
  return _internal_c1();
}
inline void TestMsg2::_internal_set_c1(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  c1_ = value;
}
inline void TestMsg2::set_c1(uint64_t value) {
  _internal_set_c1(value);
  // @@protoc_insertion_point(field_set:alisql.TestMsg2.c1)
}

// repeated uint64 c2 = 3;
inline int TestMsg2::_internal_c2_size() const {
  return c2_.size();
}
inline int TestMsg2::c2_size() const {
  return _internal_c2_size();
}
inline void TestMsg2::clear_c2() {
  c2_.Clear();
}
inline uint64_t TestMsg2::_internal_c2(int index) const {
  return c2_.Get(index);
}
inline uint64_t TestMsg2::c2(int index) const {
  // @@protoc_insertion_point(field_get:alisql.TestMsg2.c2)
  return _internal_c2(index);
}
inline void TestMsg2::set_c2(int index, uint64_t value) {
  c2_.Set(index, value);
  // @@protoc_insertion_point(field_set:alisql.TestMsg2.c2)
}
inline void TestMsg2::_internal_add_c2(uint64_t value) {
  c2_.Add(value);
}
inline void TestMsg2::add_c2(uint64_t value) {
  _internal_add_c2(value);
  // @@protoc_insertion_point(field_add:alisql.TestMsg2.c2)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TestMsg2::_internal_c2() const {
  return c2_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TestMsg2::c2() const {
  // @@protoc_insertion_point(field_list:alisql.TestMsg2.c2)
  return _internal_c2();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TestMsg2::_internal_mutable_c2() {
  return &c2_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TestMsg2::mutable_c2() {
  // @@protoc_insertion_point(field_mutable_list:alisql.TestMsg2.c2)
  return _internal_mutable_c2();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace alisql

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::alisql::PaxosMsg_MsgErrorType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_paxos_2eproto
